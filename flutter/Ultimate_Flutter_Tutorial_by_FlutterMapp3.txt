The Ultimate Flutter Tutorial for Beginners - 2025 Full Course, by Flutter Mapp
https://www.youtube.com/watch?v=3kaGC_DrUnw

Chapters
🚀 1. Key Concepts
    00:00:00​ Create a project
    00:02:22 Widget inside Widget
    00:04:56 Widget vs Argument
    00:07:12 Types
    00:09:30 Mouse over

📐 2. Basic Layouts
    00:12:12 Container
    00:16:48 Column
    00:22:10 Row
    00:25:22 Center
    00:27:17 Images
    00:32:06 Extensions (only for VS code)
    00:33:27 Stack
    00:35:48 Padding
    00:36:46 SizedBox
    00:37:33 Icon
    00:38:56 ListTile
    00:40:59 print
    00:41:47 Wrap

🐦‍🔥 3. Master Layout
    00:43:17 MaterialApp & Scaffold
    00:47:21 AppBar
    00:50:05 NavigationBar
    00:53:53 FloatingActionButton
    00:56:11 Drawer
    00:57:53 SafeArea

🔧 4. Debugging
    00:59:49 Type 1
    01:01:20 Type 2
    01:05:26 Null Safety

⚡ 5. States
    01:07:19 Stateful
    01:11:42 Recap
    01:17:18 Split your Widgets
    01:20:30 Widget Tree
    01:25:12 ValueNotifier
    01:31:41 Challenge
    01:34:30 Solution

🖋️ 6. User Inputs
    01:38:32 TextField
    01:42:33 Checkbox
    01:45:09 Arrow function
    01:46:15 Switch
    01:47:57 .adaptive
    01:49:11 Slider
    01:51:12 SingleChildScrollView
    01:52:51 GestureDetector
    01:54:01 InkWell
    01:55:34 Buttons
    01:59:07 DropdownButton

🗺️ 7. Navigation
    02:02:34 Push
    02:02:34 Pop
    02:09:16 PushReplacement
    02:10:59 Send Data Through pages

👾 8. Clean UI
    02:13:18 ClipRRect
    02:17:40 Hero
    02:22:14 SnackBar
    02:25:29 Alert
    02:29:06 Divider
    02:30:40 Card
    02:33:36 Text

📦 9. Packages
    02:36:57 Lotties
    02:43:17 FittedBox
    02:46:50 UI modification
    02:54:33 Overrides
    02:56:49 UI modification
    03:01:20 UI modification (again)
    03:06:49 Verify and fix your App
    03:14:33 UI modification
    03:18:30 Shared Preferences
    03:26:33 UI modification
    03:37:57 UI modification (again)
    03:43:43 UI modification (again & again)
    03:55:57 Flutter Launcher Icons
    04:01:44 CircleAvatar

📱 10. Responsive UI
    04:07:48 FractionallySizedBox
        FractionallySizedBox() is a layout widget that sizes its child based on a fraction
        of its parent’s size. This is useful when you want a widget to take a percentage
        of the available space (instead of fixed pixels).

        🧱 Common properties:
            widthFactor → fraction of the parent’s width to use (e.g., 0.5 means 50%).
            heightFactor → fraction of the parent’s height to use.
            alignment → positions the child within the available space.
            child → the widget inside.
        💡 Tips:
            If widthFactor or heightFactor is null, the widget will size itself to the child’s size in that dimension.
            Works great in responsive UIs.
            It does not force the parent to a size — the parent must have constraints.
        ✅ Example – Box taking 50% width and height of parent:
            FractionallySizedBox(
                widthFactor: 0.5,
                heightFactor: 0.5,
                alignment: Alignment.center,
                child: Container(
                    color: Colors.blue,
                    child: Center(
                    child: Text(
                        '50% of parent',
                        style: TextStyle(color: Colors.white),
                    ),
                    ),
                ),
            );
        ✅ Example – Full width but custom height:
                FractionallySizedBox(
                widthFactor: 1.0,
                heightFactor: 0.3,
                child: Container(
                    color: Colors.green,
                ),
            );
        🧭 Common use cases:
            Responsive layouts without hardcoding sizes
            Centering widgets proportionally
            Dynamic UI elements inside flexible containers like Column, Row, or Stack.

    04:09:55 LayoutBuilder
        LayoutBuilder() is a powerful widget that lets you build widgets dynamically based on the
        parent’s constraints. It gives you access to the maximum width and height your widget
        can use and allows you to return different UI layouts accordingly.

        🧱 Common properties:
            builder → a callback function that provides:
            BuildContext context
            BoxConstraints constraints → tells you the parent’s max/min width and height.
            child (optional) → a constant widget that can be reused inside the builder (optimization).
        💡 Tips:
            Perfect for responsive UI — e.g., mobile vs tablet layouts.
            Useful when you need to react to parent size without using MediaQuery.
            Works only during layout phase, not during paint.
        ✅ Example – Responsive text based on width:
            LayoutBuilder(
                builder: (context, constraints) {
                    if (constraints.maxWidth > 600) {
                        return Text(
                            'Wide layout (e.g., tablet)',
                            style: TextStyle(fontSize: 30),
                        );
                    } else {
                        return Text(
                            'Narrow layout (e.g., phone)',
                            style: TextStyle(fontSize: 16),
                        );
                    }
                },
            );
        ✅ Example – Building dynamic Container:
            LayoutBuilder(
                builder: (context, constraints) {
                    return Container(
                        width: constraints.maxWidth * 0.8,
                        height: constraints.maxHeight * 0.5,
                        color: Colors.blue,
                        child: Center(
                                child: Text(
                                'Width: ${constraints.maxWidth}',
                                style: TextStyle(color: Colors.white),
                            ),
                        ),
                    );
                },
            );
        🧭 Common use cases:
            Responsive UIs that adapt to different screen sizes
            Widgets inside Row, Column, or Stack that must size based on parent
            Alternative to MediaQuery for layout decisions.

    04:12:41 MediaQuery
        MediaQuery() provides information about the current device’s screen and
        view insets — like size, orientation, pixel ratio, padding, safe areas, and more.
        It’s most commonly used to build responsive UIs that adapt to different screen sizes.

        🧱 Common properties from MediaQuery.of(context):
            size → screen size (Size(width, height))
            orientation → Orientation.portrait or Orientation.landscape
            padding → areas like status bar or notch (SafeArea)
            viewInsets → keyboard area
            devicePixelRatio → number of device pixels for each logical pixel
            textScaleFactor → font scaling set by user
        💡 Tips:
            Ideal for responsive layouts.
            Can detect whether the keyboard is open (viewInsets.bottom > 0).
            Often used together with LayoutBuilder.
            Use MediaQuery.of(context) inside build methods (not globally).
        ✅ Example – Get screen width and height:
            final screenSize = MediaQuery.of(context).size;
            final width = screenSize.width;
            final height = screenSize.height;
            return Container(
                width: width * 0.8,
                height: height * 0.4,
                color: Colors.blue,
            );
        ✅ Example – Adjust layout for orientation:
            final orientation = MediaQuery.of(context).orientation;
            return orientation == Orientation.portrait
                ? Column(
                    children: [Text('Portrait Mode')],
                )
                : Row(
                    children: [Text('Landscape Mode')],
                );
        ✅ Example – Check if keyboard is open:
            final keyboardOpen = MediaQuery.of(context).viewInsets.bottom > 0;
            if (keyboardOpen) {
                print('Keyboard is visible');
            }
        🧭 Common use cases:
            Responsive UI sizing and spacing
            Adapting layout based on screen orientation
            Handling safe areas and keyboard insets
            Adjusting font sizes and paddings based on screen size.

    04:14:42 AspectRatio
        AspectRatio() is a layout widget that sizes its child to match a specific aspect
        ratio (width ÷ height). This is especially useful when you want to maintain consistent
        proportions for images, videos, cards, or containers across different screen sizes.
        🧱 Common properties:
            aspectRatio → a double that represents width ÷ height (e.g., 16 / 9).
            child → the widget inside the AspectRatio.
        💡 Tips:
            The parent must impose some constraint; otherwise, the widget won’t know how big to be.
            If the parent provides unbounded constraints, AspectRatio tries to size itself as small as possible while respecting the ratio.
            Very useful in grid layouts, media players, and image display areas.
        ✅ Example – 16:9 container (common for videos):
            AspectRatio(
                aspectRatio: 16 / 9,
                child: Container(
                        color: Colors.blue,
                        child: Center(
                        child: Text(
                            '16 : 9',
                            style: TextStyle(color: Colors.white),
                        ),
                    ),
                ),
            );
        ✅ Example – Square box (1:1 ratio):
            AspectRatio(
                aspectRatio: 1,
                child: Container(
                    color: Colors.green,
                    child: Icon(Icons.crop_square, color: Colors.white),
                ),
            );
        ✅ Example – Card with fixed ratio inside a Column:
            Column(
                children: [
                    AspectRatio(
                        aspectRatio: 4 / 3,
                        child: Card(
                            color: Colors.orange,
                            child: Center(child: Text('4:3')),
                        ),
                    ),
                ],
            );
        🧭 Common use cases:
            Maintaining video or image aspect ratios
            Responsive UI elements with proportional width/height
            Square or fixed-ratio tiles in grids and carousels.

    04:17:40 Expanded & Flexible
        *** Expanded() is a widget that expands a child of a Row, Column, or Flex to fill the available space.
            It helps distribute space proportionally among multiple children without needing fixed sizes.
            🧱 Common properties:
                child → the widget that will expand to fill available space.
                flex → an int that determines how much of the available space this child should take relative to others (default: 1).
            💡 Tips:
                Must be used inside a Row, Column, or Flex.
                Works well with other layout widgets like Spacer.
                If multiple Expanded widgets are in a row/column, their flex values determine how the remaining space is divided.
                It can’t define its own height or width; it takes the space given by the parent.
            ✅ Example – Simple Expanded inside a Row:
                Row(
                    children: [
                        Expanded(
                            child: Container(color: Colors.blue, height: 100),
                        ),
                        Expanded(
                            child: Container(color: Colors.green, height: 100),
                        ),
                    ],
                );
                👉 Each container takes up half of the row’s width.
            ✅ Example – Using flex to control proportions:
                Row(
                    children: [
                        Expanded(
                            flex: 1,
                            child: Container(color: Colors.red, height: 100),
                        ),
                        Expanded(
                            flex: 2,
                            child: Container(color: Colors.yellow, height: 100),
                        ),
                    ],
                );
                👉 The red container takes 1/3 and the yellow one 2/3 of the available width.
            ✅ Example – Inside a Column for vertical expansion:
                Column(
                    children: [
                        Expanded(
                            flex: 2,
                            child: Container(color: Colors.blue),
                        ),
                        Expanded(
                            flex: 1,
                            child: Container(color: Colors.green),
                        ),
                    ],
                );
                👉 The blue container gets twice as much height as the green one.
            🧭 Common use cases:
                Building responsive UIs without hardcoding dimensions.
                Dividing space between children evenly or proportionally.
                Combining with Flexible, Spacer, and FractionallySizedBox for adaptive layouts.

        *** Flexible is a widget that allows a child of a Row, Column, or Flex to occupy available space without
            forcing it to fill it completely. It’s similar to Expanded but gives the child more control over its own size.
            🧱 Common properties:
                child → the widget inside the Flexible.
                flex → determines how much of the remaining space to allocate relative to other flexible children.
                fit → controls how the child should fit in the allocated space:
                FlexFit.tight → forces the child to fill all allocated space (same as Expanded).
                FlexFit.loose (default) → child can be smaller than the available space.
            💡 Tips:
                Use Flexible when you want a widget to adapt but not necessarily stretch.
                Expanded is essentially Flexible(fit: FlexFit.tight).
                Great for layouts where some children should grow but keep their natural size if possible.
            ✅ Example – Basic Flexible:
                Row(
                    children: [
                        Flexible(
                            child: Container(
                                color: Colors.blue,
                                height: 100,
                            ),
                        ),
                        Flexible(
                            child: Container(
                                color: Colors.green,
                                height: 100,
                            ),
                        ),
                    ],
                );
                👉 Both containers can shrink or grow depending on space, but won’t be forced to fill it entirely.
            ✅ Example – Using flex and fit:
                Row(
                    children: [
                        Flexible(
                            flex: 1,
                            fit: FlexFit.tight,
                            child: Container(color: Colors.red, height: 100),
                        ),
                        Flexible(
                            flex: 2,
                            fit: FlexFit.loose,
                            child: Container(color: Colors.yellow, height: 100, width: 50),
                        ),
                    ],
                );
                👉 Red expands to fill its part of the space, while yellow takes only as much as it needs (even though it has more space available).
            🧭 Common use cases:
                When you want responsive widgets but still allow the child to control its size.
                Preventing forced expansion in a Row or Column.
                Combining flexible and fixed-size widgets in adaptive layouts.


🌐 11. Networking
    04:26:42 Intro
        * Bored API Documentation
            https://bored-api.appbrewery.com/

        * How to fetch data from the internet:
            https://docs.flutter.dev/cookbook/networking/fetch-Data

        * Install http package: https://pub.dev/packages/http
            flutter pub add http
            dependencies:
                http: ^1.5.0
            import 'package:http/http.dart';

    04:29:00 Get
        * Internet permission must be added for production
            Android - add to file, under <manifest...>
                android/app/src/main/AndroidManifest.xml
                    <!-- Required to fetch data from the internet. -->
                    <uses-permission android:name="android.permission.INTERNET" />
                ! note - android/app/src/debug/AndroidManifest.xml - already contains it, so it works in development out of the box

            macOS - add to the following giles
                macos/Runner/DebugProfile.entitlements
                macos/Runner/Release.entitlements
                <!-- Required to fetch data from the internet. -->
                <key>com.apple.security.network.client</key>
                <true/>
        * Use example from http package - https://pub.dev/packages/http/example
        * Use URL from Bored API

    04:37:56 Explain
        *** http.get()
            http.get() is a simple and commonly used method from the http package to send a GET request to a server.

            ✅ Summary:
                http.get() sends a GET request and returns a Response object.
                Use Uri.https() to build URLs.
                Always check the statusCode before parsing.
                Use jsonDecode() to convert JSON to Dart objects.

            🧭 Basic Example
                import 'package:http/http.dart' as http;

                void main() async {
                    // 1. Create the URI
                    var url = Uri.https('jsonplaceholder.typicode.com', '/posts/1');

                    // 2. Send GET request
                    var response = await http.get(url);

                    // 3. Handle the response
                    if (response.statusCode == 200) {
                        print('Response body: ${response.body}');
                    } else {
                        print('Request failed with status: ${response.statusCode}');
                    }
                }


        *** Uri.https()
            Uri.https() constructor is a convenient way to build secure HTTPS URLs programmatically,
            instead of manually concatenating strings.
            ✅ Summary:
                Uri.https() builds HTTPS URLs safely and cleanly.
                No need to worry about manual string encoding.
                Ideal for use with APIs and network requests.
            🧱 Syntax
                Uri.https(
                    String authority,            // e.g. "example.com"
                    String unencodedPath,        // e.g. "/api/users"
                    [Map<String, String>? queryParameters] // optional
                )

                authority: The domain name (and optional port).
                unencodedPath: The path part of the URL.
                queryParameters: A map of query string parameters (automatically encoded).
            🔸 With Query Parameters
                void main() {
                    Uri url = Uri.https(
                        'example.com',
                        '/search',
                        {'q': 'flutter', 'page': '1'},
                    );
                    print(url.toString());
                    // Output: https://example.com/search?q=flutter&page=1
                }
                👉 Notice that Uri.https() automatically encodes the query parameters correctly (e.g., spaces, special characters).
            ⚡ Real-World Use Case with HTTP Request
                When making an API call with http package:

                import 'package:http/http.dart' as http;
                void main() async {
                    Uri url = Uri.https(
                        'jsonplaceholder.typicode.com',
                        '/posts',
                        {'userId': '1'},
                    );

                    final response = await http.get(url);

                    if (response.statusCode == 200) {
                        print(response.body);
                    } else {
                        print('Request failed with status: ${response.statusCode}');
                    }
                }


        *** jsonDecode()
            jsonDecode() is used to convert a JSON string into a Dart object — typically a Map<String, dynamic>
            or a List<dynamic> depending on the structure of the JSON.
            It’s part of the dart:convert library.
            ✅ Summary:
                jsonDecode() → converts JSON string → Dart object (Map or List).
                Import dart:convert to use it.
                Always ensure the JSON string is properly formatted.
                Use model classes for cleaner code in larger apps.

            🧰 Basic usage of jsonDecode()
                import 'dart:convert';
                void main() {
                    String jsonString = '{"name": "Alice", "age": 25}';
                    // Decode the JSON string
                    Map<String, dynamic> user = jsonDecode(jsonString);
                    print(user['name']); // Alice
                    print(user['age']);  // 25
                }

            📦 Decoding a JSON Array
                import 'dart:convert';
                void main() {
                    String jsonString = '[{"id":1,"name":"Alice"},{"id":2,"name":"Bob"}]';
                    List<dynamic> users = jsonDecode(jsonString);
                    print(users[0]['name']); // Alice
                }

            🛠️ Type Casting for Safety - Since jsonDecode returns a dynamic type, it's often good practice to cast it explicitly:
                import 'dart:convert';
                void main() {
                    String jsonString = '{"id": 1, "title": "Hello"}';
                    final Map<String, dynamic> data = jsonDecode(jsonString) as Map<String, dynamic>;
                    print(data['title']); // Hello
                }

            🧭 With Model Classes - For larger apps, it’s common to parse JSON into a custom Dart model:
                import 'dart:convert';
                class User {
                    final String name;
                    final int age;

                    User({required this.name, required this.age});

                    factory User.fromJson(Map<String, dynamic> json) {
                        return User(
                            name: json['name'],
                            age: json['age'],
                        );
                    }
                }

                void main() {
                    String jsonString = '{"name":"Alice","age":25}';
                    Map<String, dynamic> jsonMap = jsonDecode(jsonString);
                    User user = User.fromJson(jsonMap);
                    print(user.name); // Alice
                }

    04:41:24 Class
        *** Convert the response into a custom Dart object
            https://docs.flutter.dev/cookbook/networking/fetch-data

            * Create a new Activity() class based on the structure of the Album Class in the example here:
                https://docs.flutter.dev/cookbook/networking/fetch-data
                - but with the parameters from Bored API
            * Convert the http.Response to an Activity (class) - from flutter docs Example

    04:47:07 FutureBuilder
        FutureBuilder is a widget that builds itself based on the latest snapshot of interaction with a Future.
        It’s perfect when you need to display UI that depends on asynchronous data
        (e.g., fetching from an API, database, or delay).

        🧱 Common properties:
            future → the Future you want to listen to.
            builder → a function that gives you a BuildContext and an AsyncSnapshot of the future’s state.
            initialData (optional) → data to display before the future completes.
        📊 AsyncSnapshot states you can check in builder:
            ConnectionState.none → no future started yet.
            ConnectionState.waiting → future is still loading.
            ConnectionState.active → future is active (often for streams).
            ConnectionState.done → future completed (either success or error).
        You can also use:
            snapshot.hasData → returns true if data is available.
            snapshot.hasError → returns true if there’s an error.
        💡 Tips:
            Use FutureBuilder for one-time asynchronous operations.
            Avoid creating the Future directly in build() (store it in a variable or initState() to prevent multiple calls).
            For continuous updates, use StreamBuilder instead.
        ✅ Example – Basic FutureBuilder with loading state:
            Future<String> fetchData() async {
                await Future.delayed(Duration(seconds: 2));
                return "Hello from Future!";
            }
            @override
            Widget build(BuildContext context) {
                return FutureBuilder<String>(
                    future: fetchData(),
                    builder: (context, snapshot) {
                        if (snapshot.connectionState == ConnectionState.waiting) {
                            return Center(child: CircularProgressIndicator());
                        } else if (snapshot.hasError) {
                            return Center(child: Text('Error: ${snapshot.error}'));
                        } else if (snapshot.hasData) {
                            return Center(child: Text(snapshot.data!));
                        } else {
                            return Center(child: Text('No data'));
                        }
                    },
                );
            }
            👉 Shows a loading spinner first, then the fetched text after the future completes.

        ✅ Example – With initialData:
            FutureBuilder<String>(
                future: fetchData(),
                initialData: "Loading...",
                builder: (context, snapshot) {
                    return Center(child: Text(snapshot.data!));
                },
            );
            👉 Displays “Loading...” immediately, then updates once the data arrives.
        🧭 Common use cases:
            Fetching API or database results.
            Waiting for initialization (e.g., shared preferences or configuration).
            Handling asynchronous computations in UI.
            Replacing setState with a clean reactive pattern for futures.

    04:53:41 AI

🎯 12. Next Steps
    04:58:50 Let's talk about State Management
        https://docs.flutter.dev/data-and-backend/state-mgmt/intro
        https://docs.flutter.dev/data-and-backend/state-mgmt/options

    05:00:59 Internationalizing
        See Chapter 51 - Localization in Flutter of Flutter Course by Vandad

    05:02:12 Firebase
        https://docs.flutter.dev/data-and-backend/firebase

    05:03:25 Publish
        https://docs.flutter.dev/deployment

    05:04:30 Animations
        *** AnimatedCrossFade()
            AnimatedCrossFade is a widget that animates a fade and size transition between two children.
            It’s commonly used to switch between two different UI states smoothly
            (e.g., showing more/less info, toggling widgets).

            🧱 Common properties:
                firstChild → the widget shown in the first state.
                secondChild → the widget shown in the second state.
                crossFadeState → controls which child is shown (CrossFadeState.showFirst or CrossFadeState.showSecond).
                duration → how long the animation lasts.
                firstCurve (optional) → animation curve for fading in the first child.
                secondCurve (optional) → animation curve for fading in the second child.
                sizeCurve (optional) → animation curve for the size transition.
            💡 Tips:
                Both children must be non-null.
                It animates both opacity and size, which makes transitions look smoother.
                If both children are very different in size, the animation might jump — you can control it with sizeCurve or wrap widgets in SizedBox.
            ✅ Example – Basic toggle between two containers:
                class CrossFadeExample extends StatefulWidget {
                    @override
                    _CrossFadeExampleState createState() => _CrossFadeExampleState();
                    }
                    class _CrossFadeExampleState extends State<CrossFadeExample> {
                    bool _showFirst = true;
                    @override
                    Widget build(BuildContext context) {
                        return Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                            AnimatedCrossFade(
                            firstChild: Container(
                                color: Colors.blue,
                                width: 200,
                                height: 200,
                                child: Center(child: Text('First')),
                            ),
                            secondChild: Container(
                                color: Colors.red,
                                width: 200,
                                height: 200,
                                child: Center(child: Text('Second')),
                            ),
                            crossFadeState: _showFirst
                                ? CrossFadeState.showFirst
                                : CrossFadeState.showSecond,
                            duration: Duration(seconds: 1),
                            ),
                            SizedBox(height: 20),
                            ElevatedButton(
                            onPressed: () {
                                setState(() {
                                _showFirst = !_showFirst;
                                });
                            },
                            child: Text('Toggle'),
                            ),
                        ],
                        );
                    }
                }
                👉 Smoothly fades and resizes between the blue and red containers.

            ✅ Example – Using curves for a smoother effect:
                AnimatedCrossFade(
                    firstChild: Text('Short text'),
                    secondChild: Text('A much longer piece of text here'),
                    crossFadeState: _showFirst
                        ? CrossFadeState.showFirst
                        : CrossFadeState.showSecond,
                    duration: Duration(milliseconds: 500),
                    firstCurve: Curves.easeIn,
                    secondCurve: Curves.easeOut,
                    sizeCurve: Curves.easeInOut,
                );
                👉 Adds easing curves to make the animation feel more natural.
            🧭 Common use cases:
                Showing/hiding extra details in a card or tile.
                Expanding a section of UI smoothly.
                Replacing one widget with another with a nice transition.
                Creating onboarding or tutorial steps.

    05:10:14 The end.
