The Ultimate Flutter Tutorial for Beginners - 2025 Full Course, by Flutter Mapp
https://www.youtube.com/watch?v=3kaGC_DrUnw

Chapters
ðŸš€ 1. Key Concepts
    00:00:00â€‹ Create a project
    00:02:22 Widget inside Widget
    00:04:56 Widget vs Argument
    00:07:12 Types
    00:09:30 Mouse over

ðŸ“ 2. Basic Layouts
    00:12:12: Container
        Container is a versatile box widget in Flutter that can be used for layout, styling, padding, margin,
        alignment, and decoration. It can contain a single child and is often used as a building block for UI design.
        Container(
            width: 100,
            height: 100,
            color: Colors.blue,
            child: Text('Hello'),
        );
    ðŸ§± Common properties:
        child â†’ the widget inside the container
        width / height â†’ size of the container
        padding â†’ space inside the container around the child (EdgeInsets)
        margin â†’ space outside the container
        decoration â†’ background color, border, border radius, gradients
        alignment â†’ alignment of the child inside the container
    âœ… Examples:
        1. Simple container with color and size:
            Container(
                width: 150,
                height: 150,
                color: Colors.red,
                child: Center(child: Text('Box')),
            );
        2. Container with padding and rounded corners:
            Container(
                padding: EdgeInsets.all(16),
                decoration: BoxDecoration(
                    color: Colors.green,
                    borderRadius: BorderRadius.circular(12),
                ),
                child: Text('Styled Container'),
            );
        3. Container with margin and alignment:
            Container(
                margin: EdgeInsets.symmetric(horizontal: 20, vertical: 10),
                alignment: Alignment.center,
                color: Colors.blue,
                child: Text('Centered Text'),
            );
    ðŸ“Œ Tip:
        Use Container when you need styling and positioning in your UI.
        For simple spacing, Padding or SizedBox can be more lightweight.
        Combine Container with Column, Row, or Stack for flexible layouts.

    00:16:48 Column
        Column is a layout widget that arranges its children vertically, from top to bottom.
        Itâ€™s commonly used to stack widgets in a vertical direction.
        Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
                Text('First'),
                Text('Second'),
            ],
        );
        ðŸ§± Common properties:
            children â†’ list of widgets arranged vertically
            mainAxisAlignment â†’ controls vertical alignment (start, center, end, spaceBetween, etc.)
            crossAxisAlignment â†’ controls horizontal alignment (start, center, end)
            mainAxisSize â†’ controls how much vertical space the column takes (max or min)
        âœ… Examples:
            1. Basic column:
                Column(
                    children: [
                        Text('First line'),
                        Text('Second line'),
                    ],
                );
            2. Centered column:
                Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    crossAxisAlignment: CrossAxisAlignment.center,
                    children: [
                        Icon(Icons.star),
                        SizedBox(height: 10),
                        Text('Favorite'),
                    ],
                );
            3. Space between elements:
                Column(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                        Text('Top'),
                        Text('Middle'),
                        Text('Bottom'),
                    ],
                );
        ðŸ“Œ Tip:
            If the content might not fit the screen, wrap the Column in a SingleChildScrollView.
            Use Expanded or Flexible inside a Column to make widgets take up available space.
            For horizontal layout, use Row.

    00:22:10 Row
        Row is a layout widget that arranges its children horizontally â€” from left to right.
        Itâ€™s ideal when you want to place multiple widgets side by side.
        Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
                Icon(Icons.star),
                Text('Star'),
            ],
        );
        ðŸ§± Common properties:
            children â†’ list of widgets arranged horizontally
            mainAxisAlignment â†’ controls horizontal alignment (start, center, end, spaceBetween, etc.)
            crossAxisAlignment â†’ controls vertical alignment (start, center, end)
            mainAxisSize â†’ controls how much horizontal space the row takes (max or min)
        âœ… Examples:
            1. Simple row:
                Row(
                    children: [
                        Icon(Icons.favorite),
                        Text('Like'),
                    ],
                );
            2. Centered row with spacing:
                Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                        Icon(Icons.home),
                        SizedBox(width: 10),
                        Text('Home'),
                    ],
                );
            3. Evenly spaced widgets:
                Row(
                    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                    children: [
                        Icon(Icons.call),
                        Icon(Icons.message),
                        Icon(Icons.share),
                    ],
                );
        ðŸ“Œ Tip:
            Row doesnâ€™t scroll by default â€” if you need scrolling, wrap it in SingleChildScrollView with scrollDirection: Axis.horizontal.
            If children overflow the screen, use Expanded or Flexible to control their sizes.
            For vertical layout, use Column instead.

    00:25:22 Center
        Centers its child both vertically and horizontally within the available space.
        Itâ€™s often used to align a single widget in the middle of the screen or inside its parent.
        Center(
            child: Text('Centered'),
        );
        ðŸ§± Common property:
            child â†’ the widget you want to center.
        âœ… Examples:
            1. Centering a text:
                Center(
                    child: Text(
                        'Welcome!',
                        style: TextStyle(fontSize: 24),
                    ),
                );
            2. Centering an image:
                Center(
                child:  Image.asset('assets/images/flutter.png'),
                );
            3. Using with Container:
                Center(
                    child: Container(
                        width: 100,
                        height: 100,
                        color: Colors.blue,
                    ),
                );
        ðŸ“Œ Tip:
            Center expands to fill the available space of its parent and then centers its child.
            If the parent has limited size, the child is centered within that area.
            Useful inside Scaffold to quickly center content on the screen.

    00:27:17 Images
        Displays an image from assets, network, file, or memory.
        Image.asset('assets/image.png');       // From assets (must configure assets: in pubspec.yaml)
        Image.network('https://example.com');  // From network
        ðŸ§± Common constructors:
            Image.asset() â†’ load image from assets
            Image.network() â†’ load image from the internet
            Image.file() â†’ load image from a local file
            Image.memory() â†’ load image from memory (e.g., Uint8List)
        ðŸ§° Common properties:
            width / height â†’ control size of the image
            fit â†’ how the image should be inscribed in its box (BoxFit.cover, contain, etc.)
            alignment â†’ how to align the image inside its box
            color / colorBlendMode â†’ apply color filters
            repeat â†’ repeat the image if needed
        âœ… Examples:
            1. Load from assets:
                Image.asset(
                    'assets/images/flutter.png',
                    width: 100,
                    height: 100,
                    fit: BoxFit.cover,
                );
            2. Load from network:
                Image.network(
                    'https://flutter.dev/images/flutter-logo-sharing.png',
                    width: 150,
                    height: 150,
                    fit: BoxFit.contain,
                );
            3. Load from file (e.g., gallery or storage):
                import 'dart:io';
                Image.file(
                    File('/path/to/image.jpg'),
                    width: 200,
                );
            4. Load from memory:
                Image.memory(
                    bytes, // Uint8List data
                    fit: BoxFit.cover,
                );
        ðŸ“Œ Tip:
            For asset images, make sure to declare them in pubspec.yaml.
            Use fit to control how images resize or crop.
            Use FadeInImage for smoother loading of network images with placeholders.

    00:32:06 Extensions (only for VS code)

    00:33:27 Stack
        Stack is a layout widget that allows you to place widgets on top of each other (like layers).
        The first child is at the bottom, and each subsequent child is stacked above it.
        Itâ€™s perfect for creating overlays, badges, floating elements, or custom designs.
        Stack(
            alignment: Alignment.center,
            children: [
                Container(width: 200, height: 200, color: Colors.red),
                Text('On top'),
            ],
        );
        ðŸ§± Common properties:
            children â†’ list of widgets stacked in order
            alignment â†’ how to align children (default: topStart)
            fit â†’ how the non-positioned children are sized (loose, expand, passthrough)
            clipBehavior â†’ controls how content is clipped outside the stack
        ðŸ‘‰ You can also position individual children using Positioned.
        âœ… Examples:
            1. Basic stack with text on top of a box:
                Stack(
                    alignment: Alignment.center,
                    children: [
                        Container(width: 200, height: 200, color: Colors.blue),
                        Text('Overlay', style: TextStyle(color: Colors.white)),
                    ],
                );
            2. Using Positioned to place widgets precisely:
                Stack(
                    children: [
                        Container(width: 300, height: 300, color: Colors.green),
                        Positioned(
                            top: 20,
                            left: 20,
                            child: Icon(Icons.star, color: Colors.yellow, size: 40),
                        ),
                        Positioned(
                            bottom: 10,
                            right: 10,
                            child: Text('Bottom right'),
                        ),
                    ],
                );
            3. Creating a profile image with a badge:
                Stack(
                    children: [
                        CircleAvatar(radius: 40, backgroundColor: Colors.blue),
                        Positioned(
                        bottom: 0,
                        right: 0,
                        child: Container(
                            width: 20,
                            height: 20,
                            decoration: BoxDecoration(
                                color: Colors.green,
                                shape: BoxShape.circle,
                                border: Border.all(color: Colors.white, width: 2),
                            ),
                        ),
                        ),
                    ],
                );
        ðŸ“Œ Tip:
            Use Stack when you need overlapping layouts.
            Combine with Positioned for precise control of element placement.
            For responsive designs, use alignment instead of hardcoded positions when possible.

    00:35:48 Padding
        Adds empty space inside its parent and around its child, helping control the layout and spacing of widgets
        without affecting their size directly. ONLY used for padding. If you need other parameters/styles - use Container()
        Padding(
            padding: EdgeInsets.all(16.0), // space on all sides
            child: Text('Hello with padding'),
        );
        ðŸ§± Common padding options:
            EdgeInsets.all(value) â†’ same padding on all sides
            EdgeInsets.symmetric(horizontal: x, vertical: y) â†’ padding on horizontal & vertical sides
            EdgeInsets.only(left: x, top: y, right: z, bottom: w) â†’ padding on specific sides
        âœ… Example:
            Padding(
                padding: EdgeInsets.symmetric(horizontal: 20, vertical: 10),
                child: Container(
                    color: Colors.blue,
                    child: Text('Padded Text'),
                ),
            );
        ðŸ“Œ Tip:
            Padding only affects the space around the child, not the size of the child itself.
            Itâ€™s often used inside Column, Row, or Stack for cleaner UI spacing.
            If only padding + size is needed use Padding() + SizedBox(). If decorations -> Container()

    00:36:46 SizedBox
        Like a Container(), but simpler -used to give a fixed width and/or height to its child or
        create empty space between widgets.
        SizedBox(
            width: 200,
            height: 100,
            child: Container(color: Colors.blue),
        );
        ðŸ§± Key uses:
            Fix the size of a widget.
            Add spacing between widgets (when child is null).
            Expand to fill all available space with SizedBox.expand().
        âœ… Example 1 - Fixed size for a widget:
            SizedBox(
                width: 200,
                height: 100,
                child: Container(color: Colors.blue),
            );
        âœ… Example 2 - Add space between widgets:
            Column(
                children: [
                    Text('Top'),
                    SizedBox(height: 20), // empty vertical space
                    Text('Bottom'),
                ],
            );
        âœ… Example 3 - Fill available space:
            SizedBox.expand(
                child: Container(color: Colors.red),
            );
        ðŸ“Œ Tip:
            SizedBox is lightweight and preferred over Container when you just need fixed spacing or sizing.
            If no child is provided, it acts as an invisible spacer.
            Can also be used as SizedBox.expand() to fill available space.

    00:37:33 Icon()
        Used to display material design icons. Itâ€™s lightweight and commonly used in
        buttons, navigation bars, and UI decorations.
        Icon(
            Icons.star,
            color: Colors.yellow,
            size: 30,
        );
        ðŸ§± Common properties:
            icon â†’ the icon to display (e.g., Icons.home, Icons.star)
            color â†’ color of the icon
            size â†’ size of the icon in logical pixels
        âœ… Examples:
            1. Basic icon:
                Icon(Icons.favorite);
            2. Colored and sized icon:
                Icon(
                    Icons.favorite,
                    color: Colors.red,
                    size: 50,
                );
            3. Icon inside a button:
                IconButton(
                    icon: Icon(Icons.add),
                    onPressed: () {
                        print('Button pressed');
                    },
                );
        ðŸ“Œ Tip:
            You can find built-in icons in Icons. class.
            For custom icons, use Image.asset() or Image.network() instead.
            Combine Icon with Row or Column for labels with icons.

    00:38:56 ListTile()
        Prebuilt widget for creating a single row in a list with a leading icon or image,
        a title, a subtitle, and a trailing widget (like an arrow or button).
        ListTile(
            leading: Icon(Icons.person),
            title: Text('John Doe'),
            subtitle: Text('Online'),
            trailing: Icon(Icons.arrow_forward),
            onTap: () {
                print('Tile tapped');
            },
        );
        ðŸ§± Common properties:
            leading â†’ Widget shown at the start (e.g., Icon, CircleAvatar)
            title â†’ Main text
            subtitle â†’ Secondary text (optional)
            trailing â†’ Widget at the end (e.g., icon, switch, button)
            onTap â†’ A
        âœ… Examples:
            1. Simple list tile:
                ListTile(
                    leading: Icon(Icons.email),
                    title: Text('Email'),
                );
            2. With subtitle and action:
                ListTile(
                    leading: CircleAvatar(child: Icon(Icons.person)),
                    title: Text('Jane Doe'),
                    subtitle: Text('Active 5 min ago'),
                    trailing: Icon(Icons.message),
                    onTap: () {
                        print('Message Jane');
                    },
                );
            3. Inside a list:
                ListView(
                    children: [
                        ListTile(title: Text('Item 1')),
                        ListTile(title: Text('Item 2')),
                        ListTile(title: Text('Item 3')),
                    ],
                );
        ðŸ“Œ Tip:
            ListTile automatically handles padding and alignment.
            You can use dense: true for a more compact look.
            Great for settings menus, contact lists, and navigation lists.

    00:40:59 print
        print() - prints to the console

    00:41:47 Wrap()
        Automatically moves its children to the next line (or column) when thereâ€™s not enough space.
        Itâ€™s perfect for chips, tags, buttons, or any content that should flow responsively.
        Like a Row(), but wraps to next line
        Wrap(
            spacing: 8.0,       // space between items horizontally
            runSpacing: 4.0,    // space between lines vertically
            children: [
                Chip(label: Text('Flutter')),
                Chip(label: Text('Dart')),
                Chip(label: Text('UI')),
            ],
        );
        ðŸ§± Common properties:
            direction â†’ layout direction (Axis.horizontal by default)
            spacing â†’ space between children in the main axis
            runSpacing â†’ space between lines (runs) in the cross axis
            alignment â†’ alignment of children in the main axis
            runAlignment â†’ alignment of each line in the cross axis
        âœ… Examples:
            1. Horizontal wrap with chips:
                Wrap(
                    spacing: 10,
                    runSpacing: 5,
                    children: [
                        Chip(label: Text('One')),
                        Chip(label: Text('Two')),
                        Chip(label: Text('Three')),
                        Chip(label: Text('Four')),
                    ],
                );
            2. Vertical wrap:
                Wrap(
                    direction: Axis.vertical,
                    spacing: 10,
                    children: [
                        Container(width: 80, height: 40, color: Colors.red),
                        Container(width: 80, height: 40, color: Colors.green),
                        Container(width: 80, height: 40, color: Colors.blue),
                    ],
                );
        ðŸ“Œ Tip:
            Use Wrap instead of Row or Column when you want auto line breaking.
            Unlike Row and Column, Wrap wonâ€™t overflow when space runs out â€” it wraps gracefully.
            Commonly used in responsive UIs.


ðŸ¦â€ðŸ”¥ 3. Master Layout
    00:43:17 MaterialApp & Scaffold

    *** MaterialApp is the root widget for apps that use Material Design.
        It provides essential features like theming, routing, navigation,
        and localization out of the box.

        MaterialApp(
            title: 'My App',
            theme: ThemeData(
                primarySwatch: Colors.blue,
            ),
            home: HomePage(),  // your first screen widget
        );

        ðŸ§± Common properties:
            title â†’ name of the app (shown in task switchers, etc.)
            theme â†’ defines colors, fonts, and overall visual style
            home â†’ the default screen shown when the app starts
            routes â†’ named routes for navigation
            initialRoute â†’ route shown at launch (instead of home)
            debugShowCheckedModeBanner â†’ remove the â€œdebugâ€ banner in debug mode
        âœ… Examples:
            1. Basic app with a home screen:
                void main() {
                    runApp(
                        MaterialApp(
                        title: 'My First App',
                        home: Scaffold(
                            appBar: AppBar(title: Text('Home')),
                            body: Center(child: Text('Hello, Flutter!')),
                        ),
                        ),
                    );
                }
            2. Using routes for navigation:
                MaterialApp(
                    initialRoute: '/',
                    routes: {
                        '/': (context) => HomePage(),
                        '/about': (context) => AboutPage(),
                    },
                );
        ðŸ“Œ Tip:
            Always wrap your Flutter app with MaterialApp if you want Material Design widgets (like Scaffold, AppBar, FloatingActionButton, etc.).
            For more control over appearance, use theme or darkTheme.
            For iOS-style apps, you can use CupertinoApp instead.
            ðŸ‘‰ Typically, MaterialApp is placed inside runApp() at the very top of your app.

    *** Scaffold is a basic layout structure for Material Design apps.
        It provides predefined slots for common app elements like AppBar, Drawer,
        BottomNavigationBar, FloatingActionButton, and body content.
        Scaffold(
            appBar: AppBar(
                title: Text('Home'),
            ),
            body: Center(
                child: Text('Hello, Flutter!'),
            ),
            floatingActionButton: FloatingActionButton(
                onPressed: () {},
                child: Icon(Icons.add),
            ),
        );
        ðŸ§± Common properties:
            appBar â†’ top bar of the screen (AppBar)
            body â†’ main content area (usually Column, Row, ListView, etc.)
            floatingActionButton â†’ circular action button
            drawer â†’ side navigation panel
            bottomNavigationBar â†’ bar at the bottom for navigation
            backgroundColor â†’ background color of the Scaffold
        âœ… Examples:
            1. Basic scaffold with text:
                Scaffold(
                    appBar: AppBar(title: Text('Home')),
                    body: Center(child: Text('Welcome!')),
                );
            2. Scaffold with FAB and bottom navigation:
                Scaffold(
                    appBar: AppBar(title: Text('Dashboard')),
                    body: ListView(children: [Text('Item 1'), Text('Item 2')]),
                    floatingActionButton: FloatingActionButton(
                        onPressed: () {},
                        child: Icon(Icons.add),
                    ),
                    bottomNavigationBar: BottomNavigationBar(
                        items: [
                        BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Home'),
                        BottomNavigationBarItem(icon: Icon(Icons.settings), label: 'Settings'),
                        ],
                    ),
                );
        ðŸ“Œ Tip:
            Scaffold is the foundation for most Material apps.
            It handles layout, safe area, scrolling, and keyboard overlap automatically.
            Combine with AppBar, Drawer, and FloatingActionButton for a complete UI structure.

    00:47:21 AppBar
        The top navigation bar in a Material Design app.
        It usually contains the title, actions, navigation buttons,
        and optional widgets like tabs.
        AppBar(
            title: Text('Home'),
            actions: [
                IconButton(
                    icon: Icon(Icons.search),
                    onPressed: () {},
                ),
            ],
        );
        ðŸ§± Common properties:
            title â†’ main text or widget displayed in the center (or start)
            leading â†’ widget at the start (commonly back button or drawer icon)
            actions â†’ list of widgets displayed at the end (icons, buttons)
            backgroundColor â†’ color of the AppBar
            centerTitle â†’ centers the title (default depends on platform)
            elevation â†’ shadow depth of the AppBar
        âœ… Examples:
            1. Simple AppBar with title:
                AppBar(
                    title: Text('My App'),
                );
            2. AppBar with actions and leading:
                AppBar(
                    leading: Icon(Icons.menu),
                    title: Text('Dashboard'),
                    actions: [
                        IconButton(icon: Icon(Icons.search), onPressed: () {}),
                        IconButton(icon: Icon(Icons.notifications), onPressed: () {}),
                    ],
                );
            3. Customized AppBar:
                AppBar(
                    title: Text('Profile'),
                    backgroundColor: Colors.green,
                    centerTitle: true,
                    elevation: 4,
                );
        ðŸ“Œ Tip:
            AppBar is usually used inside a Scaffold.
            You can place custom widgets inside title or actions for flexible UI.
            For tabs, combine AppBar with TabBar inside a DefaultTabController.

    00:50:05 NavigationBar
        NavigationBar is the modern Material 3 widget for bottom navigation in Flutter.
        It lets users switch between top-level destinations of your app with a clean, minimal design.
        Itâ€™s the updated alternative to the older BottomNavigationBar.
        NavigationBar(
            selectedIndex: 0,
            onDestinationSelected: (int index) {
                print('Selected index: $index');
            },
            destinations: const [
                NavigationDestination(
                    icon: Icon(Icons.home),
                    label: 'Home',
                ),
                NavigationDestination(
                    icon: Icon(Icons.settings),
                    label: 'Settings',
                ),
            ],
        );
        ðŸ§± Common properties:
            selectedIndex â†’ currently active tab index
            onDestinationSelected â†’ callback when a tab is tapped
            destinations â†’ list of NavigationDestination widgets (tabs), must be 2+ items
            backgroundColor â†’ background of the bar
            indicatorColor â†’ highlight color for the selected destination
            animationDuration â†’ how fast the transition animates
        âœ… Examples:
            1. Basic navigation bar with two tabs:
                Scaffold(
                    body: Center(child: Text('Home')),
                    bottomNavigationBar: NavigationBar(
                        selectedIndex: 0,
                        onDestinationSelected: (index) {
                        // Handle navigation logic
                        },
                        destinations: const [
                        NavigationDestination(icon: Icon(Icons.home), label: 'Home'),
                        NavigationDestination(icon: Icon(Icons.person), label: 'Profile'),
                        ],
                    ),
                );
            2. Navigation bar with 3 destinations and custom colors:
                NavigationBar(
                    backgroundColor: Colors.white,
                    indicatorColor: Colors.blue.shade100,
                    selectedIndex: 1,
                    onDestinationSelected: (index) {},
                    destinations: const [
                        NavigationDestination(icon: Icon(Icons.home), label: 'Home'),
                        NavigationDestination(icon: Icon(Icons.search), label: 'Search'),
                        NavigationDestination(icon: Icon(Icons.settings), label: 'Settings'),
                    ],
                );
        ðŸ“Œ Tip:
            NavigationBar works great with Scaffold as bottomNavigationBar.
            Itâ€™s part of Material 3, so make sure useMaterial3: true is set in your ThemeData.
            Use NavigationDestination to define each tabâ€™s icon and label.
            For older Material 2 designs, use BottomNavigationBar instead.

    00:53:53 FloatingActionButton()
        FloatingActionButton (FAB) is a circular button that floats above the UI, usually in the bottom-right
        corner. Itâ€™s used for primary actions on a screen â€” like adding, creating, or composing something.
        FloatingActionButton(
            onPressed: () {
                print('FAB pressed');
            },
            child: Icon(Icons.add),
        );
        ðŸ§± Common properties:
            onPressed â†’ callback when the button is tapped (required)
            child â†’ usually an Icon or small Text widget
            backgroundColor â†’ background color of the FAB
            foregroundColor â†’ color of the icon/text inside the FAB
            tooltip â†’ text shown when the user long-presses
            shape â†’ custom shape for the button (e.g., rounded rectangle)
        !!! If multiple buttons are needed, can be wrapped with Row/column:
            floatingActionButton: Row(
                mainAxisSize: MainAxisSize.min,
                FloatingActionButton(...),
                SizedBox(width: 10),
                FloatingActionButton(...),
            )
        âœ… Examples:

            1. Basic FAB with an icon:
                Scaffold(
                    floatingActionButton: FloatingActionButton(
                        onPressed: () {
                        print('FAB tapped');
                        },
                        child: Icon(Icons.add),
                    ),
                );
            2. FAB with custom color and tooltip:
                FloatingActionButton(
                    backgroundColor: Colors.green,
                    foregroundColor: Colors.white,
                    tooltip: 'Add Item',
                    onPressed: () {},
                    child: Icon(Icons.add),
                );
            3. Extended FAB with label:
                FloatingActionButton.extended(
                    onPressed: () {},
                    icon: Icon(Icons.edit),
                    label: Text('Edit'),
                );
        ðŸ“Œ Tip:
            FAB is typically placed inside a Scaffold using floatingActionButton.
            Use FloatingActionButton.extended when you want text + icon.
            You can position it with floatingActionButtonLocation.
            It should represent the most important action on the screen.

    00:56:11 Drawer()
        Drawer is a side navigation panel that slides in from the left (or right) of the screen.
        Itâ€™s commonly used for app-wide navigation â€” like accessing profile, settings, or other sections.
        Itâ€™s typically paired with Scaffold and accessed via the hamburger menu in the AppBar.
        Drawer(
            child: ListView(
                padding: EdgeInsets.zero,
                children: [
                    DrawerHeader(
                        decoration: BoxDecoration(color: Colors.blue),
                        child: Text('Menu', style: TextStyle(color: Colors.white)),
                    ),
                    ListTile(
                        leading: Icon(Icons.home),
                        title: Text('Home'),
                        onTap: () {},
                    ),
                    ListTile(
                        leading: Icon(Icons.settings),
                        title: Text('Settings'),
                        onTap: () {},
                    ),
                ],
            ),
        );
        ðŸ§± Common properties:
            child â†’ the widget displayed inside the drawer (commonly a ListView)
            backgroundColor â†’ background color of the drawer
            You can use DrawerHeader or UserAccountsDrawerHeader for profile info.
        âœ… Examples:
            1. Basic Drawer with menu items:
                Scaffold(
                    appBar: AppBar(title: Text('Drawer Example')),
                    drawer: Drawer(
                        child: ListView(
                        padding: EdgeInsets.zero,
                        children: [
                            DrawerHeader(
                                decoration: BoxDecoration(color: Colors.blue),
                                child: Text('Navigation', style: TextStyle(color: Colors.white)),
                            ),
                            ListTile(
                                leading: Icon(Icons.home),
                                title: Text('Home'),
                                onTap: () {},
                            ),
                            ListTile(
                                leading: Icon(Icons.settings),
                                title: Text('Settings'),
                                onTap: () {},
                            ),
                        ],
                        ),
                    ),
                    body: Center(child: Text('Content area')),
                );
            2. Drawer with user account header:
                Drawer(
                    child: ListView(
                        children: [
                        UserAccountsDrawerHeader(
                            accountName: Text('John Doe'),
                            accountEmail: Text('john@example.com'),
                            currentAccountPicture: CircleAvatar(
                            child: Icon(Icons.person),
                            ),
                        ),
                        ListTile(leading: Icon(Icons.home), title: Text('Home')),
                        ListTile(leading: Icon(Icons.logout), title: Text('Logout')),
                        ],
                    ),
                );
        ðŸ“Œ Tip:
            Place Drawer in Scaffoldâ€™s drawer: property to enable the hamburger menu automatically.
            Use Navigator.pop(context) inside onTap to close the drawer after selecting an option.
            You can also use endDrawer to make the drawer slide in from the right side.

    00:57:53 SafeArea()
        SafeArea is a widget that automatically adds padding to its child so that it doesnâ€™t get covered
        by system UI elements like the status bar, notch, or navigation bar. Itâ€™s super useful for making
        your layout look good on all devices, especially phones with notches.
        SafeArea(
            child: Text('Hello, Safe Area!'),
        );
        ðŸ§± Common properties:
            child â†’ the widget to be displayed safely
            left, top, right, bottom â†’ booleans to enable/disable padding on specific sides
            minimum â†’ adds extra padding beyond the safe area
            maintainBottomViewPadding â†’ keeps bottom padding even when keyboard is open
        âœ… Examples:
            1. Basic use to avoid notch overlap:
                SafeArea(
                    child: Scaffold(
                        appBar: AppBar(title: Text('Safe Area Example')),
                        body: Center(child: Text('Content fits within safe area')),
                    ),
                );
            2. Disable padding on specific sides:
                SafeArea(
                    top: false,  // ignore top safe area
                    child: Container(
                        color: Colors.red,
                        child: Text('Safe on sides but not on top'),
                    ),
                );
            3. With extra padding:
                SafeArea(
                    minimum: EdgeInsets.all(16),
                    child: Text('Extra space around me'),
                );
        ðŸ“Œ Tip:
            Use SafeArea around your main screen content to handle different screen cutouts automatically.
            You donâ€™t need it inside a Scaffold with AppBar, since the AppBar already respects the top safe area.
            Itâ€™s especially useful for full-screen UIs or custom layouts without an AppBar.


ðŸ”§ 4. Debugging
    00:59:49 Type 1
    01:01:20 Type 2
    01:05:26 Null Safety


âš¡ 5. States
    01:07:19 Stateful
        setState() is a method used inside a StatefulWidget to update the UI when the state changes.
        When you call setState(), Flutter rebuilds the widget tree to reflect the new state.
        setState(() {
            // Update your state variables here
        });
        ðŸ§± Key points:
            Only works inside the State class of a StatefulWidget.
            It triggers a rebuild of the widget to reflect the updated data.
            Should be used only when the state actually changes (to avoid unnecessary rebuilds).
        âœ… Examples:
            1. Simple counter:
                int counter = 0;
                void _incrementCounter() {
                    setState(() {
                        counter++;
                    });
                }
            2. Usage in a widget:
                Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                        Text('Count: $counter'),
                        ElevatedButton(
                        onPressed: _incrementCounter,
                        child: Text('Increase'),
                        ),
                    ],
                );
        ðŸ“Œ Tip:
            Keep the code inside setState minimalâ€”only update variables, not perform heavy logic.
            If your state is complex or shared across multiple widgets, consider using state management solutions like Provider, Bloc, or Riverpod.
            setState() does not rebuild the entire app, only the widget where itâ€™s called.

    01:11:42 Recap
        Stateful Widget passed to runApp(const MyApp());
        returns Material App
        home: Scaffold(
            appBar: AppBar(),
            bottomNavigationBar: NavigationBar(
                onDestinationSelected: (value) {
                    setState(() {
                        // use value
                    });
                }
            ),
        ),


    01:17:18 Split your Widgets
        Refactor widgets into separate files

    01:20:30 Widget Tree
        Refactor the main Scaffold() into a separate widget_tree.dart file outside of main
        Main should be simple and only return the MaterialApp(home: WidgetTree())


    01:25:12 ValueNotifier
        ValueNotifier is a special class that holds a single value and notifies its listeners
        whenever that value changes. Itâ€™s a lightweight alternative to setState() for updating UI reactively.

        ValueNotifier: holds the data
        ValueListenableBuilder: listens to the data (don't need the setState())

        ðŸ§± Key points:
            Works well with ValueListenableBuilder to rebuild widgets automatically.
            value property holds the current state.
            When you update value, all listeners are notified.
            Doesnâ€™t require a StatefulWidget â€” can be used inside StatelessWidget too.
        âœ… Examples:
            1. Simple counter using ValueNotifier:
                final counter = ValueNotifier<int>(0);
                ValueListenableBuilder<int>(
                    valueListenable: counter,
                    builder: (context, value, child) {
                        return Text('Count: $value');
                    },
                );
                FloatingActionButton(
                    onPressed: () {
                        counter.value++;
                    },
                    child: Icon(Icons.add),
                );
            2. Updating a string value:
                final nameNotifier = ValueNotifier<String>('Guest');
                ValueListenableBuilder<String>(
                    valueListenable: nameNotifier,
                    builder: (context, value, _) {
                        return Text('Hello, $value');
                    },
                );
                // Update value
                nameNotifier.value = 'John';
        ðŸ“Œ Tip:
            ValueNotifier is great for small, localized state management.
            For complex state, use more robust solutions like Provider, Riverpod, or Bloc.
            Unlike setState, you can use it even in a StatelessWidget because the rebuild happens through the listener.


    01:31:41 Challenge
        Create an AppBar button to switch the theme between Light and Dark mode

    01:34:30 Solution
        notifiers.dart
            - Create a new bool notifier - isDarkModeNotifier
        widget_tree.dart
            - In the AppBar, create actions: [IconButton(),]
            - IconButton
                - onPressed: toggle value of isDarkModeNotifier.value between true and false
                - icon: Icon(Icons.light_mode)
                - To switch icon between dark and light mode: wrap Icon() in ValueListenableBuilder(context, isDarkMode, child)
                    - in the builder function return Icon(value ? light mode icon : dark mode icon)
        main.dart
            - To switch theme between light and dark, wrap MaterialApp in ValueListenableBuilder(context, isDarkMode, child)
            - switch theme: ThemeData(brightness: isDarkMode ? Brightness.dart : Brightness.light),


ðŸ–‹ï¸ 6. User Inputs
    01:38:32 TextField()
        TextField is a widget that allows the user to enter and edit text input.
        Itâ€™s commonly used for forms, search bars, login screens, and other input fields.

        TextField(
            decoration: InputDecoration(
                labelText: 'Enter your name',
            ),
        );

        ðŸ§± Common properties:
            controller â†’ controls and retrieves the text entered (TextEditingController)
            decoration â†’ adds styling like labels, icons, borders (InputDecoration)
            keyboardType â†’ specifies the keyboard type (e.g., TextInputType.emailAddress)
            obscureText â†’ hides text for passwords
            onChanged â†’ callback triggered when text changes
            onSubmitted â†’ callback when user presses "done" or "enter"
            maxLines â†’ allows multiple lines of input
        âœ… Examples:
            1. Basic text field:
                TextField(
                    decoration: InputDecoration(
                        hintText: 'Type something...',
                    ),
                );
            2. Text field with controller:
                final myController = TextEditingController();
                    TextField(
                    controller: myController,
                    decoration: InputDecoration(labelText: 'Your name'),
                );
                // Access value:
                print(myController.text);
            3. Password field:
                TextField(
                    obscureText: true,
                    decoration: InputDecoration(
                        labelText: 'Password',
                        prefixIcon: Icon(Icons.lock),
                    ),
                );
            4. Multiline text field:
                TextField(
                    maxLines: 5,
                    decoration: InputDecoration(
                        labelText: 'Write a message',
                    ),
                );
        ðŸ“Œ Tip:
            Always dispose of your TextEditingController in dispose() to prevent memory leaks.
            Use TextFormField for validation when working inside a form.
            Combine with InputDecoration for professional-looking input fields.

    TextEditingController()
        TextEditingController is a controller class used to manage and control the text inside a
        TextField or TextFormField. It lets you read, modify, and listen to changes in the text input.

        ðŸ§± Common uses:
            Retrieve the current text: myController.text
            Set new text: myController.text = 'Hello';
            Clear the field: myController.clear();
        âœ… Examples:
            Listen for text changes:
                final myController = TextEditingController();
                myController.addListener(() {
                    print(myController.text);
                });

            1. Basic usage with TextField:
                final nameController = TextEditingController();
                TextField(
                    controller: nameController,
                    decoration: InputDecoration(
                        labelText: 'Enter your name',
                    ),
                );
                // Access the text value
                print(nameController.text);
            2. Updating the text programmatically:
                nameController.text = 'John Doe';
            3. Listening for changes:
                nameController.addListener(() {
                    print('Current text: ${nameController.text}');
                });
            4. Clearing the text:
                IconButton(
                    icon: Icon(Icons.clear),
                    onPressed: () {
                        nameController.clear();
                    },
                );
        ðŸ“Œ Tip:
            Always dispose of controllers when theyâ€™re no longer needed to free resources:
                @override
                void dispose() {
                    nameController.dispose();
                    super.dispose();
                }
            Use one controller per text field when you need to track or control input directly.
            Combine with TextField or TextFormField for reactive and interactive input fields.

    01:42:33 Checkbox()
        Checkbox is a material design widget that lets the user select or deselect an option (true/false).
        Itâ€™s typically used for settings, preferences, or multi-select lists.
        see also CheckboxListTile(title: )

        Checkbox(
            value: isChecked,
            onChanged: (bool? newValue) {
                setState(() {
                    isChecked = newValue!;
                });
            },
        );
        ðŸ§± Common properties:
            value â†’ current state (true or false)
            onChanged â†’ callback triggered when user taps the checkbox
            activeColor â†’ color when the box is checked
            checkColor â†’ color of the check mark
            tristate â†’ allows null as a third state if set to true
        âœ… Examples:
            1. Basic checkbox with state:
                bool isChecked = false;
                    Checkbox(
                    value: isChecked,
                    onChanged: (bool? newValue) {
                        setState(() {
                        isChecked = newValue!;
                        });
                    },
                );
            2. Colored checkbox:
                Checkbox(
                    value: isChecked,
                    activeColor: Colors.green,
                    checkColor: Colors.white,
                    onChanged: (bool? value) {
                        setState(() {
                        isChecked = value!;
                        });
                    },
                );
            3. Checkbox with label (using Row or CheckboxListTile):
                Row(
                    children: [
                        Checkbox(
                        value: isChecked,
                        onChanged: (value) {
                            setState(() {
                            isChecked = value!;
                            });
                        },
                        ),
                        Text('Accept Terms & Conditions'),
                    ],
                );
            4. Or more conveniently:
                CheckboxListTile(
                    title: Text('Accept Terms & Conditions'),
                    value: isChecked,
                    onChanged: (value) {
                        setState(() {
                        isChecked = value!;
                        });
                    },
                );
        ðŸ“Œ Tip:
            Always manage the state (with setState, ValueNotifier, or a state management solution).
            Use CheckboxListTile() for a built-in label and better accessibility.
            Use Switch if you want a toggle-style interaction instead of a checkbox.

    01:45:09 Arrow function
        A short syntax for writing functions that contain only one expression.
        It uses the => operator instead of curly braces {} and return.

        returnType functionName(parameters) => expression;
        is the same as:
        returnType functionName(parameters) {
            return expression;
        }

    01:46:15 Switch()
        Switch is a material design toggle button that represents a boolean (on/off) state.
        Itâ€™s commonly used in settings screens or anywhere the user needs to enable or disable a feature.
        See also: SwitchListTile(title: )

        Switch(
            value: isSwitched,
            onChanged: (bool value) {
                setState(() {
                    isSwitched = value;
                });
            },
        );
        ðŸ§± Common properties:
            value â†’ current state of the switch (true or false)
            onChanged â†’ function called when the user toggles the switch
            activeColor â†’ color of the thumb (the circle) when the switch is ON
            activeTrackColor â†’ color of the track when ON
            inactiveThumbColor â†’ color of the thumb when OFF
            inactiveTrackColor â†’ color of the track when OFF
        âœ… Examples:
            1. Basic switch:
                bool isSwitched = false;
                Switch(
                value: isSwitched,
                onChanged: (bool value) {
                    setState(() {
                    isSwitched = value;
                    });
                },
                );
            2. Customized switch:
                Switch(
                    value: isSwitched,
                    activeColor: Colors.green,
                    activeTrackColor: Colors.lightGreenAccent,
                    inactiveThumbColor: Colors.grey,
                    inactiveTrackColor: Colors.black26,
                    onChanged: (bool value) {
                        setState(() {
                        isSwitched = value;
                        });
                    },
                );
            3. With a label (SwitchListTile):
                SwitchListTile(
                    title: Text('Enable Notifications'),
                    value: isSwitched,
                    onChanged: (bool value) {
                        setState(() {
                        isSwitched = value;
                        });
                    },
                );
        ðŸ“Œ Tip:
            Switch itself only shows the toggle; use SwitchListTile for an easy labeled version.
            You must handle the state (like setState or ValueNotifier).
            Use Switch for binary (yes/no) options â€” not multiple choices.

    01:47:57 .adaptive
        The .adaptive constructor is available on some Flutter widgets to make them
        automatically adapt to the platformâ€™s design â€” Material (Android) or Cupertino (iOS).
        That means:
            On Android â†’ shows a Material-style widget.
            On iOS â†’ shows a Cupertino-style (iOS-style) widget.

        Example with Switch.adaptive:
            Switch.adaptive(
                value: isSwitched,
                onChanged: (bool value) {
                    setState(() {
                    isSwitched = value;
                    });
                },
            );
            ðŸŸ¢ On Android â†’ it looks like a Material toggle switch
            âšª On iOS â†’ it looks like an iOS-style Cupertino switch

        âœ… Other widgets with .adaptive constructors:
            Switch.adaptive
            Checkbox.adaptive
            CircularProgressIndicator.adaptive
            Slider.adaptive
        ðŸ“Œ Tip:
            Use .adaptive when you want your appâ€™s UI to feel native on both Android and iOS.
            Flutter automatically detects the current platform using Theme.of(context).platform.
            Itâ€™s a quick way to achieve cross-platform design consistency without manually coding for each platform.

    01:49:11 Slider
        Slider is a material design input widget that lets users select a value from a continuous range by
        sliding a thumb along a track. Itâ€™s perfect for choosing numbers like volume, brightness, or progress.

        Slider(
            value: currentValue,
            min: 0,
            max: 100,
            onChanged: (double newValue) {
                setState(() {
                    currentValue = newValue;
                });
            },
        );

        ðŸ§± Common properties:
            value â†’ current slider position (a double)
            min â†’ minimum possible value
            max â†’ maximum possible value
            onChanged â†’ called when user moves the slider
            divisions â†’ splits the slider into discrete steps
            label â†’ shows a label when the slider thumb is dragged
            activeColor â†’ color of the track before the thumb
            inactiveColor â†’ color of the track after the thumb
        âœ… Examples:
            1. Basic slider:
                double volume = 0.5;
                Slider(
                    value: volume,
                    min: 0,
                    max: 1,
                    onChanged: (double value) {
                        setState(() {
                        volume = value;
                        });
                    },
                );
            2. Slider with divisions and labels:
                double rating = 3;
                Slider(
                    value: rating,
                    min: 0,
                    max: 5,
                    divisions: 5,
                    label: '$rating stars',
                    onChanged: (double value) {
                        setState(() {
                            rating = value;
                        });
                    },
                );
            3. Customized colors:
                Slider(
                    value: brightness,
                    min: 0,
                    max: 100,
                    activeColor: Colors.orange,
                    inactiveColor: Colors.grey,
                    onChanged: (double value) {
                        setState(() {
                            brightness = value;
                        });
                    },
                );
        ðŸ“Œ Tip:
            Slider only supports double values â€” you can round it using .round() if needed.
            Use Slider.adaptive() to automatically get iOS (Cupertino) or Android (Material) style.
            For range selection (e.g., min and max values), use RangeSlider.


    01:51:12 SingleChildScrollView
        SingleChildScrollView is a scrollable widget that allows a single child (like a Column, Row, or Container)
        to be scrolled when its content is too large to fit on the screen.
        Itâ€™s perfect for forms, long text, or any layout that might overflow vertically or horizontally.

        SingleChildScrollView(
            child: Column(
                children: [
                    Text('Item 1'),
                    Text('Item 2'),
                    // more widgets...
                ],
            ),
        );

        ðŸ§± Common properties:
            child â†’ the widget to scroll (usually a Column or Row)
            scrollDirection â†’ direction of scrolling (Axis.vertical or Axis.horizontal)
            padding â†’ space around the scrollable content
            reverse â†’ reverses the scroll direction
            physics â†’ defines scroll behavior (e.g., BouncingScrollPhysics, NeverScrollableScrollPhysics)
        âœ… Examples:
            1. Vertical scroll (default):
                SingleChildScrollView(
                    child: Column(
                        children: List.generate(
                            20,
                            (index) => Padding(
                                padding: const EdgeInsets.all(8.0),
                                child: Text('Item $index'),
                            ),
                        ),
                    ),
                );
            2. Horizontal scroll:
                SingleChildScrollView(
                scrollDirection: Axis.horizontal,
                    child: Row(
                        children: [
                            Container(width: 100, height: 100, color: Colors.red),
                            Container(width: 100, height: 100, color: Colors.green),
                            Container(width: 100, height: 100, color: Colors.blue),
                        ],
                    ),
                );
            3. With padding and physics:
                SingleChildScrollView(
                    padding: EdgeInsets.all(16),
                    physics: BouncingScrollPhysics(),
                    child: Column(
                        children: [
                            Text('Scrollable Content'),
                            // more widgets...
                        ],
                    ),
                );
        ðŸ“Œ Tip:
            SingleChildScrollView is great for small-to-medium lists â€” for large, dynamic data use ListView instead.
            Always wrap the child in a layout like Column or Row â€” not multiple siblings directly.
            When used inside a Column, wrap it with Expanded or give it a constrained height (like using SizedBox) to avoid overflow errors.

    01:52:51 GestureDetector
        GestureDetector is a widget that detects gestures (taps, swipes, long presses, swipes, drags etc.) on its child.
        It doesnâ€™t have a visible UI itself â€” it simply wraps another widget to make it interactive.

        GestureDetector(
            onTap: () {
                print('Widget tapped!');
            },
            child: Container(
                color: Colors.blue,
                width: 100,
                height: 100,
                child: Center(child: Text('Tap me')),
            ),
        );

        ðŸ§± Common gesture callbacks:
            onTap â†’ single tap
            onDoubleTap â†’ double tap
            onLongPress â†’ long press
            onPanUpdate â†’ drag or swipe
            onVerticalDragUpdate / onHorizontalDragUpdate â†’ directional drag
            onTapDown / onTapUp â†’ when touch starts and ends
            âœ… Examples:
                1. Tap and print message:
                    GestureDetector(
                        onTap: () {
                            print('Tapped!');
                        },
                        child: Icon(Icons.favorite, size: 50, color: Colors.red),
                    );
                2. Long press to change color:
                    Color boxColor = Colors.blue;
                        GestureDetector(
                            onLongPress: () {
                                setState(() {
                                boxColor = Colors.green;
                                });
                            },
                            child: Container(
                                width: 100,
                                height: 100,
                                color: boxColor,
                        ),
                    );
                3. Drag to move a widget:
                    Offset position = Offset(100, 100);
                        GestureDetector(
                        onPanUpdate: (details) {
                            setState(() {
                            position += details.delta;
                            });
                        },
                        child: Positioned(
                            left: position.dx,
                            top: position.dy,
                            child: Container(width: 50, height: 50, color: Colors.red),
                        ),
                    );

        ðŸ“Œ Tip:
            GestureDetector is invisible; you must wrap a widget to make it interactive.
            Use it when you need custom gestures beyond standard buttons or switches.
            You can combine multiple gesture callbacks in one detector.
            For simple taps, InkWell() or InkResponse() can also be used, providing ripple effects.
        ðŸ§  Common use cases:
            Custom buttons or interactive areas.
            Detecting swipes or drags for animations.
            Wrapping images or icons to make them clickable.
            Building gesture-based navigation or custom UI effects.


    01:54:01 InkWell
        InkWell is a material design widget that provides a ripple effect when tapped.
        Itâ€™s used to make any widget clickable while giving visual feedback to the user.
        Unlike GestureDetector, InkWell shows a ripple animation on tap.

        InkWell(
            onTap: () {
                print('Tapped!');
            },
            child: Container(
                padding: EdgeInsets.all(16),
                child: Text('Click Me'),
            ),
        );

        ðŸ§± Common properties:
            onTap â†’ callback when tapped
            onDoubleTap â†’ double tap
            onLongPress â†’ long press
            onTapDown / onTapUp â†’ touch start/end
            borderRadius â†’ rounds ripple corners
            splashColor â†’ ripple color
            highlightColor â†’ color when pressed
        âœ… Examples:
            1. Simple InkWell with ripple effect:
                InkWell(
                    onTap: () {
                        print('Card tapped!');
                    },
                    child: Card(
                        child: Padding(
                        padding: EdgeInsets.all(16),
                        child: Text('Tap this card'),
                        ),
                    ),
                );
            2. InkWell with rounded corners and custom splash color:
                InkWell(
                    onTap: () {},
                    borderRadius: BorderRadius.circular(12),
                    splashColor: Colors.greenAccent,
                    child: Container(
                        padding: EdgeInsets.all(16),
                        child: Text('Tap me'),
                    ),
                );
            3. InkWell for an image button:
                InkWell(
                    onTap: () {
                        print('Image tapped');
                    },
                    child: Image.asset('assets/button.png', width: 100),
                );
        ðŸ“Œ Tip:
            InkWell must be inside a Material widget (like Card, Container with Material, or Scaffold) for the ripple effect to show.
            Use GestureDetector if you donâ€™t need a ripple.
            Combine with borderRadius to match the shape of the child for better visual appeal.

    01:55:34 Buttons
        ElevatedButton is a Material Design button with a background color and elevation, giving it a raised look.
        ElevatedButton(
            onPressed: () {
                print('Button pressed');
            },
            child: Text('Click Me'),
        );
        ðŸ§± Common properties:
            onPressed â†’ callback when the button is tapped (set null to disable)
            child â†’ widget inside the button (usually Text or Icon)
            style â†’ customize the button (ButtonStyle)
            onLongPress â†’ callback when long-pressed
        âœ… Examples:
            1. Basic ElevatedButton:
                ElevatedButton(
                    onPressed: () {
                        print('Pressed!');
                    },
                    child: Text('Submit'),
                );
            2. Disabled button:
                ElevatedButton(
                    onPressed: null,  // Disabled
                    child: Text('Disabled'),
                );
            3. Styled button:
                ElevatedButton(
                    onPressed: () {},
                    style: ElevatedButton.styleFrom(
                        primary: Colors.green,       // Background color
                        onPrimary: Colors.white,     // Text color
                        padding: EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                    ),
                    child: Text('Styled Button'),
                );
            4. ElevatedButton with icon:
                ElevatedButton.icon(
                    onPressed: () {},
                    icon: Icon(Icons.send),
                    label: Text('Send'),
                );
        ðŸ“Œ Tip:
            Use ElevatedButton for important actions that need emphasis.
            Customize appearance using style or ElevatedButton.styleFrom.
            For secondary actions, consider TextButton or OutlinedButton instead.
        ðŸ§± Other Buttons:
            ElevatedButton()
            ElevatedButton.icon()
            TextButton()
            OutlinedButton()
            FilledButton()
            IconButton()
            FloatingActionButton()
            AdaptiveButton()
            DisabledButton()
            StyledButton()
            BackButton()
            CloseButton()
            * DropdownButton()

    01:59:07 DropdownButton
        DropdownButton is a widget that lets users select one value from a list of items
        displayed in a dropdown menu. Itâ€™s commonly used for forms, filters, or settings menus.

        DropdownButton<String>(
            value: selectedValue,
            items: <String>['One', 'Two', 'Three'].map((String value) {
                return DropdownMenuItem<String>(
                    value: value,
                    child: Text(value),
                );
            }).toList(),
            onChanged: (String? newValue) {
                setState(() {
                    selectedValue = newValue!;
                });
            },
        );

        ðŸ§± Common properties:
            value â†’ currently selected item
            items â†’ list of DropdownMenuItem widgets
            onChanged â†’ called when a new item is selected
            hint â†’ widget displayed when no value is selected
            icon â†’ custom dropdown arrow
            isExpanded â†’ makes the button take all available horizontal space
            dropdownColor â†’ background color of dropdown menu
            underline â†’ widget shown below the button (can remove with SizedBox())
        âœ… Examples:
            1. Simple dropdown:
                String dropdownValue = 'Apple';
                DropdownButton<String>(
                    value: dropdownValue,
                    items: <String>['Apple', 'Banana', 'Cherry']
                        .map((String value) {
                        return DropdownMenuItem<String>(
                        value: value,
                        child: Text(value),
                        );
                    }).toList(),
                    onChanged: (String? newValue) {
                        setState(() {
                        dropdownValue = newValue!;
                        });
                    },
                );
            2. Dropdown with hint and no underline:
                String? selectedColor;
                DropdownButton<String>(
                    hint: Text('Select a color'),
                    value: selectedColor,
                    underline: SizedBox(),
                    items: ['Red', 'Green', 'Blue'].map((color) {
                        return DropdownMenuItem(
                        value: color,
                        child: Text(color),
                        );
                    }).toList(),
                    onChanged: (value) {
                        setState(() {
                        selectedColor = value;
                        });
                    },
                );
            3. Expanded dropdown:
                DropdownButton<String>(
                    isExpanded: true,
                    value: selectedValue,
                    items: ['Small', 'Medium', 'Large'].map((size) {
                        return DropdownMenuItem(
                        value: size,
                        child: Text(size),
                        );
                    }).toList(),
                    onChanged: (value) {
                        setState(() {
                        selectedValue = value!;
                        });
                    },
                );
        ðŸ“Œ Tip:
            Use DropdownButtonFormField inside a Form for better validation and styling.
            To remove the underline, set underline: SizedBox().
            For a custom look, wrap it in a Container or Card with decoration.

ðŸ—ºï¸ 7. Navigation
    02:02:34 Push
    02:02:34 Pop
    02:09:16 PushReplacement
    02:10:59 Send Data Through pages

ðŸ‘¾ 8. Clean UI
    02:13:18 ClipRRect
    02:17:40 Hero
    02:22:14 SnackBar
    02:25:29 Alert
    02:29:06 Divider
    02:30:40 Card
    02:33:36 Text

ðŸ“¦ 9. Packages
    02:36:57 Lotties
    02:43:17 FittedBox
    02:46:50 UI modification
    02:54:33 Overrides
    02:56:49 UI modification
    03:01:20 UI modification (again)
    03:06:49 Verify and fix your App
    03:14:33 UI modification
    03:18:30 Shared Preferences
    03:26:33 UI modification
    03:37:57 UI modification (again)
    03:43:43 UI modification (again & again)
    03:55:57 Flutter Launcher Icons
    04:01:44 CircleAvatar

ðŸ“± 10. Responsive UI
    04:07:48 FractionallySizedBox
    04:09:55 LayoutBuilder
    04:12:41 MediaQuery
    04:14:42 AspectRatio
    04:17:40 Expanded & Flexible

ðŸŒ 11. Networking
    04:26:42 Intro
    04:29:00 Get
    04:37:56 Explain
    04:41:24 Class
    04:47:07 FutureBuilder
    04:53:41 AI

ðŸŽ¯ 12. Next Steps
    04:58:50 Let's talk about State Management
    05:00:59 Internationalizing
    05:02:12 Firebase
    05:03:25 Publish
    05:04:30 Animations
    05:10:14 The end.
