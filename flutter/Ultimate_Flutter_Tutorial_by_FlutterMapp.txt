The Ultimate Flutter Tutorial for Beginners - 2025 Full Course, by Flutter Mapp
https://www.youtube.com/watch?v=3kaGC_DrUnw

Chapters
🚀 1. Key Concepts
    00:00:00​ Create a project
    00:02:22 Widget inside Widget
    00:04:56 Widget vs Argument
    00:07:12 Types
    00:09:30 Mouse over

📐 2. Basic Layouts
    00:12:12: Container
        Container is a versatile box widget in Flutter that can be used for layout, styling, padding, margin,
        alignment, and decoration. It can contain a single child and is often used as a building block for UI design.
        Container(
            width: 100,
            height: 100,
            color: Colors.blue,
            child: Text('Hello'),
        );
    🧱 Common properties:
        child → the widget inside the container
        width / height → size of the container
        padding → space inside the container around the child (EdgeInsets)
        margin → space outside the container
        decoration → background color, border, border radius, gradients
        alignment → alignment of the child inside the container
    📌 Tip:
        Use Container when you need styling and positioning in your UI.
        For simple spacing, Padding or SizedBox can be more lightweight.
        Combine Container with Column, Row, or Stack for flexible layouts.

    00:16:48 Column
        Column is a layout widget that arranges its children vertically, from top to bottom.
        It’s commonly used to stack widgets in a vertical direction.
        Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
                Text('First'),
                Text('Second'),
            ],
        );
        🧱 Common properties:
            children → list of widgets arranged vertically
            mainAxisAlignment → controls vertical alignment (start, center, end, spaceBetween, etc.)
            crossAxisAlignment → controls horizontal alignment (start, center, end)
            mainAxisSize → controls how much vertical space the column takes (max or min)
        📌 Tip:
            If the content might not fit the screen, wrap the Column in a SingleChildScrollView.
            Use Expanded or Flexible inside a Column to make widgets take up available space.
            For horizontal layout, use Row.

    00:22:10 Row
        Row is a layout widget that arranges its children horizontally — from left to right.
        It’s ideal when you want to place multiple widgets side by side.
        Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
                Icon(Icons.star),
                Text('Star'),
            ],
        );
        🧱 Common properties:
            children → list of widgets arranged horizontally
            mainAxisAlignment → controls horizontal alignment (start, center, end, spaceBetween, etc.)
            crossAxisAlignment → controls vertical alignment (start, center, end)
            mainAxisSize → controls how much horizontal space the row takes (max or min)
        📌 Tip:
            Row doesn’t scroll by default — if you need scrolling, wrap it in SingleChildScrollView with scrollDirection: Axis.horizontal.
            If children overflow the screen, use Expanded or Flexible to control their sizes.
            For vertical layout, use Column instead.

    00:25:22 Center
        Centers its child both vertically and horizontally within the available space.
        It’s often used to align a single widget in the middle of the screen or inside its parent.
        Center(
            child: Text('Centered'),
        );
        🧱 Common property:
            child → the widget you want to center.
        📌 Tip:
            Center expands to fill the available space of its parent and then centers its child.
            If the parent has limited size, the child is centered within that area.
            Useful inside Scaffold to quickly center content on the screen.

    00:27:17 Images
        Displays an image from assets, network, file, or memory.
        Image.asset('assets/image.png');       // From assets (must configure assets: in pubspec.yaml)
        Image.network('https://example.com');  // From network
        🧱 Common constructors:
            Image.asset() → load image from assets
            Image.network() → load image from the internet
            Image.file() → load image from a local file
            Image.memory() → load image from memory (e.g., Uint8List)
        🧰 Common properties:
            width / height → control size of the image
            fit → how the image should be inscribed in its box (BoxFit.cover, contain, etc.)
            alignment → how to align the image inside its box
            color / colorBlendMode → apply color filters
            repeat → repeat the image if needed
        📌 Tip:
            For asset images, make sure to declare them in pubspec.yaml.
            Use fit to control how images resize or crop.
            Use FadeInImage for smoother loading of network images with placeholders.

    00:32:06 Extensions (only for VS code)

    00:33:27 Stack
        Stack is a layout widget that allows you to place widgets on top of each other (like layers).
        The first child is at the bottom, and each subsequent child is stacked above it.
        It’s perfect for creating overlays, badges, floating elements, or custom designs.
        Stack(
            alignment: Alignment.center,
            children: [
                Container(width: 200, height: 200, color: Colors.red),
                Text('On top'),
            ],
        );
        🧱 Common properties:
            children → list of widgets stacked in order
            alignment → how to align children (default: topStart)
            fit → how the non-positioned children are sized (loose, expand, passthrough)
            clipBehavior → controls how content is clipped outside the stack
            👉 You can also position individual children using Positioned.
        📌 Tip:
            Use Stack when you need overlapping layouts.
            Combine with Positioned for precise control of element placement.
            For responsive designs, use alignment instead of hardcoded positions when possible.

    00:35:48 Padding
        Adds empty space inside its parent and around its child, helping control the layout and spacing of widgets
        without affecting their size directly. ONLY used for padding. If you need other parameters/styles - use Container()
        Padding(
            padding: EdgeInsets.all(16.0), // space on all sides
            child: Text('Hello with padding'),
        );
        🧱 Common padding options:
            EdgeInsets.all(value) → same padding on all sides
            EdgeInsets.symmetric(horizontal: x, vertical: y) → padding on horizontal & vertical sides
            EdgeInsets.only(left: x, top: y, right: z, bottom: w) → padding on specific sides
        📌 Tip:
            Padding only affects the space around the child, not the size of the child itself.
            It’s often used inside Column, Row, or Stack for cleaner UI spacing.
            If only padding + size is needed use Padding() + SizedBox(). If decorations -> Container()

    00:36:46 SizedBox
        Like a Container(), but simpler -used to give a fixed width and/or height to its child or
        create empty space between widgets.
        SizedBox(
            width: 200,
            height: 100,
            child: Container(color: Colors.blue),
        );
        🧱 Key uses:
            Fix the size of a widget.
            Add spacing between widgets (when child is null).
            Expand to fill all available space with SizedBox.expand().
        📌 Tip:
            SizedBox is lightweight and preferred over Container when you just need fixed spacing or sizing.
            If no child is provided, it acts as an invisible spacer.
            Can also be used as SizedBox.expand() to fill available space.

    00:37:33 Icon
        Used to display material design icons. It’s lightweight and commonly used in
        buttons, navigation bars, and UI decorations.
        Icon(
            Icons.star,
            color: Colors.yellow,
            size: 30,
        );
        🧱 Common properties:
            icon → the icon to display (e.g., Icons.home, Icons.star)
            color → color of the icon
            size → size of the icon in logical pixels
        📌 Tip:
            You can find built-in icons in Icons. class.
            For custom icons, use Image.asset() or Image.network() instead.
            Combine Icon with Row or Column for labels with icons.

    00:38:56 ListTile
        Prebuilt widget for creating a single row in a list with a leading icon or image,
        a title, a subtitle, and a trailing widget (like an arrow or button).
        ListTile(
            leading: Icon(Icons.person),
            title: Text('John Doe'),
            subtitle: Text('Online'),
            trailing: Icon(Icons.arrow_forward),
            onTap: () {
                print('Tile tapped');
            },
        );
        🧱 Common properties:
            leading → Widget shown at the start (e.g., Icon, CircleAvatar)
            title → Main text
            subtitle → Secondary text (optional)
            trailing → Widget at the end (e.g., icon, switch, button)
            onTap → A
        📌 Tip:
            ListTile automatically handles padding and alignment.
            You can use dense: true for a more compact look.
            Great for settings menus, contact lists, and navigation lists.

    00:40:59 print
        print() - prints to the console

    00:41:47 Wrap
        Automatically moves its children to the next line (or column) when there’s not enough space.
        It’s perfect for chips, tags, buttons, or any content that should flow responsively.
        Like a Row(), but wraps to next line
        Wrap(
            spacing: 8.0,       // space between items horizontally
            runSpacing: 4.0,    // space between lines vertically
            children: [
                Chip(label: Text('Flutter')),
                Chip(label: Text('Dart')),
                Chip(label: Text('UI')),
            ],
        );
        🧱 Common properties:
            direction → layout direction (Axis.horizontal by default)
            spacing → space between children in the main axis
            runSpacing → space between lines (runs) in the cross axis
            alignment → alignment of children in the main axis
            runAlignment → ali
        📌 Tip:
            Use Wrap instead of Row or Column when you want auto line breaking.
            Unlike Row and Column, Wrap won’t overflow when space runs out — it wraps gracefully.
            Commonly used in responsive UIs.


🐦‍🔥 3. Master Layout
    00:43:17 MaterialApp & Scaffold

    *** MaterialApp is the root widget for apps that use Material Design.
        It provides essential features like theming, routing, navigation,
        and localization out of the box.

        MaterialApp(
            title: 'My App',
            theme: ThemeData(
                primarySwatch: Colors.blue,
            ),
            home: HomePage(),  // your first screen widget
        );

        🧱 Common properties:
            title → name of the app (shown in task switchers, etc.)
            theme → defines colors, fonts, and overall visual style
            home → the default screen shown when the app starts
            routes → named routes for navigation
            initialRoute → route shown at launch (instead of home)

                MaterialApp(
                    initialRoute: '/',
                    routes: {
                        '/': (context) => HomePage(),
                        '/about': (context) => AboutPage(),
                    },
                );

            debugShowCheckedModeBanner → remove the “debug” banner in debug mode
        📌 Tip:
            Always wrap your Flutter app with MaterialApp if you want Material Design widgets (like Scaffold, AppBar, FloatingActionButton, etc.).
            For more control over appearance, use theme or darkTheme.
            For iOS-style apps, you can use CupertinoApp instead.
            👉 Typically, MaterialApp is placed inside runApp() at the very top of your app.

    *** Scaffold is a basic layout structure for Material Design apps.
        It provides predefined slots for common app elements like AppBar, Drawer,
        BottomNavigationBar, FloatingActionButton, and body content.
        Scaffold(
            appBar: AppBar(
                title: Text('Home'),
            ),
            body: Center(
                child: Text('Hello, Flutter!'),
            ),
            floatingActionButton: FloatingActionButton(
                onPressed: () {},
                child: Icon(Icons.add),
            ),
        );
        🧱 Common properties:
            appBar → top bar of the screen (AppBar)
            body → main content area (usually Column, Row, ListView, etc.)
            floatingActionButton → circular action button
            drawer → side navigation panel
            bottomNavigationBar → bar at the bottom for navigation
            backgroundColor → background color of the Scaffold
        📌 Tip:
            Scaffold is the foundation for most Material apps.
            It handles layout, safe area, scrolling, and keyboard overlap automatically.
            Combine with AppBar, Drawer, and FloatingActionButton for a complete UI structure.

    00:47:21 AppBar
        The top navigation bar in a Material Design app.
        It usually contains the title, actions, navigation buttons,
        and optional widgets like tabs.
        AppBar(
            title: Text('Home'),
            actions: [
                IconButton(
                    icon: Icon(Icons.search),
                    onPressed: () {},
                ),
            ],
        );
        🧱 Common properties:
            title → main text or widget displayed in the center (or start)
            leading → widget at the start (commonly back button or drawer icon)
            actions → list of widgets displayed at the end (icons, buttons)
            backgroundColor → color of the AppBar
            centerTitle → centers the title (default depends on platform)
            elevation → shadow depth of the AppBar
        📌 Tip:
            AppBar is usually used inside a Scaffold.
            You can place custom widgets inside title or actions for flexible UI.
            For tabs, combine AppBar with TabBar inside a DefaultTabController.

    00:50:05 NavigationBar
        NavigationBar is the modern Material 3 widget for bottom navigation in Flutter.
        It lets users switch between top-level destinations of your app with a clean, minimal design.
        It’s the updated alternative to the older BottomNavigationBar.
        NavigationBar(
            selectedIndex: 0,
            onDestinationSelected: (int index) {
                print('Selected index: $index');
            },
            destinations: const [
                NavigationDestination(
                    icon: Icon(Icons.home),
                    label: 'Home',
                ),
                NavigationDestination(
                    icon: Icon(Icons.settings),
                    label: 'Settings',
                ),
            ],
        );
        🧱 Common properties:
            selectedIndex → currently active tab index
            onDestinationSelected → callback when a tab is tapped
            destinations → list of NavigationDestination widgets (tabs), must be 2+ items
            backgroundColor → background of the bar
            indicatorColor → highlight color for the selected destination
            animationDuration → how fast the transition animates
        📌 Tip:
            NavigationBar works great with Scaffold as bottomNavigationBar.
            It’s part of Material 3, so make sure useMaterial3: true is set in your ThemeData.
            Use NavigationDestination to define each tab’s icon and label.
            For older Material 2 designs, use BottomNavigationBar instead.

    00:53:53 FloatingActionButton
        FloatingActionButton (FAB) is a circular button that floats above the UI, usually in the bottom-right
        corner. It’s used for primary actions on a screen — like adding, creating, or composing something.
        FloatingActionButton(
            onPressed: () {
                print('FAB pressed');
            },
            child: Icon(Icons.add),
        );
        🧱 Common properties:
            onPressed → callback when the button is tapped (required)
            child → usually an Icon or small Text widget
            backgroundColor → background color of the FAB
            foregroundColor → color of the icon/text inside the FAB
            tooltip → text shown when the user long-presses
            shape → custom shape for the button (e.g., rounded rectangle)
        ! If multiple buttons are needed, can be wrapped with Row/column:
        floatingActionButton: Row(
            mainAxisSize: MainAxisSize.min,
            FloatingActionButton(...),
            SizedBox(width: 10),
            FloatingActionButton(...),
        )
        📌 Tip:
            FAB is typically placed inside a Scaffold using floatingActionButton.
            Use FloatingActionButton.extended when you want text + icon.
            You can position it with floatingActionButtonLocation.
            It should represent the most important action on the screen.

    00:56:11 Drawer
        Drawer is a side navigation panel that slides in from the left (or right) of the screen.
        It’s commonly used for app-wide navigation — like accessing profile, settings, or other sections.
        It’s typically paired with Scaffold and accessed via the hamburger menu in the AppBar.
        Drawer(
            child: ListView(
                padding: EdgeInsets.zero,
                children: [
                    DrawerHeader(
                        decoration: BoxDecoration(color: Colors.blue),
                        child: Text('Menu', style: TextStyle(color: Colors.white)),
                    ),
                    ListTile(
                        leading: Icon(Icons.home),
                        title: Text('Home'),
                        onTap: () {},
                    ),
                    ListTile(
                        leading: Icon(Icons.settings),
                        title: Text('Settings'),
                        onTap: () {},
                    ),
                ],
            ),
        );
        🧱 Common properties:
            child → the widget displayed inside the drawer (commonly a ListView)
            backgroundColor → background color of the drawer
            You can use DrawerHeader or UserAccountsDrawerHeader for profile info.
        📌 Tip:
            Place Drawer in Scaffold’s drawer: property to enable the hamburger menu automatically.
            Use Navigator.pop(context) inside onTap to close the drawer after selecting an option.
            You can also use endDrawer to make the drawer slide in from the right side.

    00:57:53 SafeArea
        SafeArea is a widget that automatically adds padding to its child so that it doesn’t get covered
        by system UI elements like the status bar, notch, or navigation bar. It’s super useful for making
        your layout look good on all devices, especially phones with notches.
        SafeArea(
            child: Text('Hello, Safe Area!'),
        );
        🧱 Common properties:
            child → the widget to be displayed safely
            left, top, right, bottom → booleans to enable/disable padding on specific sides
            minimum → adds extra padding beyond the safe area
            maintainBottomViewPadding → keeps bottom padding even when keyboard is open
        📌 Tip:
            Use SafeArea around your main screen content to handle different screen cutouts automatically.
            You don’t need it inside a Scaffold with AppBar, since the AppBar already respects the top safe area.
            It’s especially useful for full-screen UIs or custom layouts without an AppBar.


🔧 4. Debugging
    00:59:49 Type 1
    01:01:20 Type 2
    01:05:26 Null Safety


⚡ 5. States
    01:07:19 Stateful
        setState() is a method used inside a StatefulWidget to update the UI when the state changes.
        When you call setState(), Flutter rebuilds the widget tree to reflect the new state.
        setState(() {
            // Update your state variables here
        });
        🧱 Key points:
            Only works inside the State class of a StatefulWidget.
            It triggers a rebuild of the widget to reflect the updated data.
            Should be used only when the state actually changes (to avoid unnecessary rebuilds).
        📌 Tip:
            Keep the code inside setState minimal—only update variables, not perform heavy logic.
            If your state is complex or shared across multiple widgets, consider using state management solutions like Provider, Bloc, or Riverpod.
            setState() does not rebuild the entire app, only the widget where it’s called.

    01:11:42 Recap
        Stateful Widget passed to runApp(const MyApp());
        returns Material App
        home: Scaffold(
            appBar: AppBar(),
            bottomNavigationBar: NavigationBar(
                onDestinationSelected: (value) {
                    setState(() {
                        // use value
                    });
                }
            ),
        ),


    01:17:18 Split your Widgets
        Refactor widgets into separate files

    01:20:30 Widget Tree
        Refactor the main Scaffold() into a separate widget_tree.dart file outside of main
        Main should be simple and only return the MaterialApp(home: WidgetTree())


    01:25:12 ValueNotifier
        ValueNotifier is a special class that holds a single value and notifies its listeners
        whenever that value changes. It’s a lightweight alternative to setState() for updating UI reactively.

        ValueNotifier: holds the data
        ValueListenableBuilder: listens to the data (don't need the setState())

        1. Simple counter using ValueNotifier:

        final counter = ValueNotifier<int>(0);

        ValueListenableBuilder<int>(
            valueListenable: counter,
            builder: (context, value, child) {
                return Text('Count: $value');
            },
        );
        FloatingActionButton(
            onPressed: () {
                counter.value++;
            },
            child: Icon(Icons.add),
        );

        2. Updating a string value:

        final nameNotifier = ValueNotifier<String>('Guest');

        ValueListenableBuilder<String>(
            valueListenable: nameNotifier,
            builder: (context, value, _) {
                return Text('Hello, $value');
            },
        );

        // Update value
        nameNotifier.value = 'John';

        🧱 Key points:
            Works well with ValueListenableBuilder to rebuild widgets automatically.
            value property holds the current state.
            When you update value, all listeners are notified.
            Doesn’t require a StatefulWidget — can be used inside StatelessWidget too.

        📌 Tip:
            ValueNotifier is great for small, localized state management.
            For complex state, use more robust solutions like Provider, Riverpod, or Bloc.
            Unlike setState, you can use it even in a StatelessWidget because the rebuild happens through the listener.


    01:31:41 Challenge
        Create an AppBar button to switch the theme between Light and Dark mode

    01:34:30 Solution
        notifiers.dart
            - Create a new bool notifier - isDarkModeNotifier
        widget_tree.dart
            - In the AppBar, create actions: [IconButton(),]
            - IconButton
                - onPressed: toggle value of isDarkModeNotifier.value between true and false
                - icon: Icon(Icons.light_mode)
                - To switch icon between dark and light mode: wrap Icon() in ValueListenableBuilder(context, isDarkMode, child)
                    - in the builder function return Icon(value ? light mode icon : dark mode icon)
        main.dart
            - To switch theme between light and dark, wrap MaterialApp in ValueListenableBuilder(context, isDarkMode, child)
            - switch theme: ThemeData(brightness: isDarkMode ? Brightness.dart : Brightness.light),


🖋️ 6. User Inputs
    01:38:32 TextField
        TextField is a widget that allows the user to enter and edit text input.
        It’s commonly used for forms, search bars, login screens, and other input fields.

        TextField(
            decoration: InputDecoration(
                labelText: 'Enter your name',
            ),
        );

        🧱 Common properties:
            controller → controls and retrieves the text entered (TextEditingController)
            decoration → adds styling like labels, icons, borders (InputDecoration)
            keyboardType → specifies the keyboard type (e.g., TextInputType.emailAddress)
            obscureText → hides text for passwords
            onChanged → callback triggered when text changes
            onSubmitted → callback when user presses "done" or "enter"
            maxLines → allows multiple lines of input
        📌 Tip:
            Always dispose of your TextEditingController in dispose() to prevent memory leaks.
            Use TextFormField for validation when working inside a form.
            Combine with InputDecoration for professional-looking input fields.

    TextEditingController()
        TextEditingController is a controller class used to manage and control the text inside a
        TextField or TextFormField. It lets you read, modify, and listen to changes in the text input.

        Listen for text changes:
            final myController = TextEditingController();
            myController.addListener(() {
                print(myController.text);
            });

        Basic usage with TextField:
            final nameController = TextEditingController();
            TextField(
                controller: nameController,
                decoration: InputDecoration(
                    labelText: 'Enter your name',
                ),
            );
            // Access the text value
            print(nameController.text);

        🧱 Common uses:
            Retrieve the current text: myController.text
            Set new text: myController.text = 'Hello';
            Clear the field: myController.clear();
        📌 Tip:
            Always dispose of controllers when they’re no longer needed to free resources:
                @override
                void dispose() {
                    nameController.dispose();
                    super.dispose();
                }
            Use one controller per text field when you need to track or control input directly.
            Combine with TextField or TextFormField for reactive and interactive input fields.

    01:42:33 Checkbox
        Checkbox is a material design widget that lets the user select or deselect an option (true/false).
        It’s typically used for settings, preferences, or multi-select lists.
        Checkbox(
            value: isChecked,
            onChanged: (bool? newValue) {
                setState(() {
                    isChecked = newValue!;
                });
            },
        );
        🧱 Common properties:
            value → current state (true or false)
            onChanged → callback triggered when user taps the checkbox
            activeColor → color when the box is checked
            checkColor → color of the check mark
            tristate → allows null as a third state if set to true


    01:45:09 Arrow function
    01:46:15 Switch
    01:47:57 .adaptive
    01:49:11 Slider
    01:51:12 SingleChildScrollView
    01:52:51 GestureDetector
    01:54:01 InkWell
    01:55:34 Buttons
    01:59:07 DropdownButton

🗺️ 7. Navigation
    02:02:34 Push
    02:02:34 Pop
    02:09:16 PushReplacement
    02:10:59 Send Data Through pages

👾 8. Clean UI
    02:13:18 ClipRRect
    02:17:40 Hero
    02:22:14 SnackBar
    02:25:29 Alert
    02:29:06 Divider
    02:30:40 Card
    02:33:36 Text

📦 9. Packages
    02:36:57 Lotties
    02:43:17 FittedBox
    02:46:50 UI modification
    02:54:33 Overrides
    02:56:49 UI modification
    03:01:20 UI modification (again)
    03:06:49 Verify and fix your App
    03:14:33 UI modification
    03:18:30 Shared Preferences
    03:26:33 UI modification
    03:37:57 UI modification (again)
    03:43:43 UI modification (again & again)
    03:55:57 Flutter Launcher Icons
    04:01:44 CircleAvatar

📱 10. Responsive UI
    04:07:48 FractionallySizedBox
    04:09:55 LayoutBuilder
    04:12:41 MediaQuery
    04:14:42 AspectRatio
    04:17:40 Expanded & Flexible

🌐 11. Networking
    04:26:42 Intro
    04:29:00 Get
    04:37:56 Explain
    04:41:24 Class
    04:47:07 FutureBuilder
    04:53:41 AI

🎯 12. Next Steps
    04:58:50 Let's talk about State Management
    05:00:59 Internationalizing
    05:02:12 Firebase
    05:03:25 Publish
    05:04:30 Animations
    05:10:14 The end.
