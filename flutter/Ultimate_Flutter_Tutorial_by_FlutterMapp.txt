The Ultimate Flutter Tutorial for Beginners - 2025 Full Course, by Flutter Mapp
https://www.youtube.com/watch?v=3kaGC_DrUnw

Chapters
üöÄ 1. Key Concepts
    00:00:00‚Äã Create a project
    00:02:22 Widget inside Widget
    00:04:56 Widget vs Argument
    00:07:12 Types
    00:09:30 Mouse over

üìê 2. Basic Layouts
    00:12:12: Container
        Container is a versatile box widget in Flutter that can be used for layout, styling, padding, margin,
        alignment, and decoration. It can contain a single child and is often used as a building block for UI design.
        Container(
            width: 100,
            height: 100,
            color: Colors.blue,
            child: Text('Hello'),
        );
    üß± Common properties:
        child ‚Üí the widget inside the container
        width / height ‚Üí size of the container
        padding ‚Üí space inside the container around the child (EdgeInsets)
        margin ‚Üí space outside the container
        decoration ‚Üí background color, border, border radius, gradients
        alignment ‚Üí alignment of the child inside the container
    üìå Tip:
        Use Container when you need styling and positioning in your UI.
        For simple spacing, Padding or SizedBox can be more lightweight.
        Combine Container with Column, Row, or Stack for flexible layouts.

    00:16:48 Column
        Column is a layout widget that arranges its children vertically, from top to bottom.
        It‚Äôs commonly used to stack widgets in a vertical direction.
        Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
                Text('First'),
                Text('Second'),
            ],
        );
        üß± Common properties:
            children ‚Üí list of widgets arranged vertically
            mainAxisAlignment ‚Üí controls vertical alignment (start, center, end, spaceBetween, etc.)
            crossAxisAlignment ‚Üí controls horizontal alignment (start, center, end)
            mainAxisSize ‚Üí controls how much vertical space the column takes (max or min)
        üìå Tip:
            If the content might not fit the screen, wrap the Column in a SingleChildScrollView.
            Use Expanded or Flexible inside a Column to make widgets take up available space.
            For horizontal layout, use Row.

    00:22:10 Row
        Row is a layout widget that arranges its children horizontally ‚Äî from left to right.
        It‚Äôs ideal when you want to place multiple widgets side by side.
        Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
                Icon(Icons.star),
                Text('Star'),
            ],
        );
        üß± Common properties:
            children ‚Üí list of widgets arranged horizontally
            mainAxisAlignment ‚Üí controls horizontal alignment (start, center, end, spaceBetween, etc.)
            crossAxisAlignment ‚Üí controls vertical alignment (start, center, end)
            mainAxisSize ‚Üí controls how much horizontal space the row takes (max or min)
        üìå Tip:
            Row doesn‚Äôt scroll by default ‚Äî if you need scrolling, wrap it in SingleChildScrollView with scrollDirection: Axis.horizontal.
            If children overflow the screen, use Expanded or Flexible to control their sizes.
            For vertical layout, use Column instead.

    00:25:22 Center
        Centers its child both vertically and horizontally within the available space.
        It‚Äôs often used to align a single widget in the middle of the screen or inside its parent.
        Center(
            child: Text('Centered'),
        );
        üß± Common property:
            child ‚Üí the widget you want to center.
        üìå Tip:
            Center expands to fill the available space of its parent and then centers its child.
            If the parent has limited size, the child is centered within that area.
            Useful inside Scaffold to quickly center content on the screen.

    00:27:17 Images
        Displays an image from assets, network, file, or memory.
        Image.asset('assets/image.png');       // From assets (must configure assets: in pubspec.yaml)
        Image.network('https://example.com');  // From network
        üß± Common constructors:
            Image.asset() ‚Üí load image from assets
            Image.network() ‚Üí load image from the internet
            Image.file() ‚Üí load image from a local file
            Image.memory() ‚Üí load image from memory (e.g., Uint8List)
        üß∞ Common properties:
            width / height ‚Üí control size of the image
            fit ‚Üí how the image should be inscribed in its box (BoxFit.cover, contain, etc.)
            alignment ‚Üí how to align the image inside its box
            color / colorBlendMode ‚Üí apply color filters
            repeat ‚Üí repeat the image if needed
        üìå Tip:
            For asset images, make sure to declare them in pubspec.yaml.
            Use fit to control how images resize or crop.
            Use FadeInImage for smoother loading of network images with placeholders.

    00:32:06 Extensions (only for VS code)

    00:33:27 Stack
        Stack is a layout widget that allows you to place widgets on top of each other (like layers).
        The first child is at the bottom, and each subsequent child is stacked above it.
        It‚Äôs perfect for creating overlays, badges, floating elements, or custom designs.
        Stack(
            alignment: Alignment.center,
            children: [
                Container(width: 200, height: 200, color: Colors.red),
                Text('On top'),
            ],
        );
        üß± Common properties:
            children ‚Üí list of widgets stacked in order
            alignment ‚Üí how to align children (default: topStart)
            fit ‚Üí how the non-positioned children are sized (loose, expand, passthrough)
            clipBehavior ‚Üí controls how content is clipped outside the stack
            üëâ You can also position individual children using Positioned.
        üìå Tip:
            Use Stack when you need overlapping layouts.
            Combine with Positioned for precise control of element placement.
            For responsive designs, use alignment instead of hardcoded positions when possible.

    00:35:48 Padding
        Adds empty space inside its parent and around its child, helping control the layout and spacing of widgets
        without affecting their size directly. ONLY used for padding. If you need other parameters/styles - use Container()
        Padding(
            padding: EdgeInsets.all(16.0), // space on all sides
            child: Text('Hello with padding'),
        );
        üß± Common padding options:
            EdgeInsets.all(value) ‚Üí same padding on all sides
            EdgeInsets.symmetric(horizontal: x, vertical: y) ‚Üí padding on horizontal & vertical sides
            EdgeInsets.only(left: x, top: y, right: z, bottom: w) ‚Üí padding on specific sides
        üìå Tip:
            Padding only affects the space around the child, not the size of the child itself.
            It‚Äôs often used inside Column, Row, or Stack for cleaner UI spacing.
            If only padding + size is needed use Padding() + SizedBox(). If decorations -> Container()

    00:36:46 SizedBox
        Like a Container(), but simpler -used to give a fixed width and/or height to its child or
        create empty space between widgets.
        SizedBox(
            width: 200,
            height: 100,
            child: Container(color: Colors.blue),
        );
        üß± Key uses:
            Fix the size of a widget.
            Add spacing between widgets (when child is null).
            Expand to fill all available space with SizedBox.expand().
        üìå Tip:
            SizedBox is lightweight and preferred over Container when you just need fixed spacing or sizing.
            If no child is provided, it acts as an invisible spacer.
            Can also be used as SizedBox.expand() to fill available space.

    00:37:33 Icon
        Used to display material design icons. It‚Äôs lightweight and commonly used in
        buttons, navigation bars, and UI decorations.
        Icon(
            Icons.star,
            color: Colors.yellow,
            size: 30,
        );
        üß± Common properties:
            icon ‚Üí the icon to display (e.g., Icons.home, Icons.star)
            color ‚Üí color of the icon
            size ‚Üí size of the icon in logical pixels
        üìå Tip:
            You can find built-in icons in Icons. class.
            For custom icons, use Image.asset() or Image.network() instead.
            Combine Icon with Row or Column for labels with icons.

    00:38:56 ListTile
        Prebuilt widget for creating a single row in a list with a leading icon or image,
        a title, a subtitle, and a trailing widget (like an arrow or button).
        ListTile(
            leading: Icon(Icons.person),
            title: Text('John Doe'),
            subtitle: Text('Online'),
            trailing: Icon(Icons.arrow_forward),
            onTap: () {
                print('Tile tapped');
            },
        );
        üß± Common properties:
            leading ‚Üí Widget shown at the start (e.g., Icon, CircleAvatar)
            title ‚Üí Main text
            subtitle ‚Üí Secondary text (optional)
            trailing ‚Üí Widget at the end (e.g., icon, switch, button)
            onTap ‚Üí A
        üìå Tip:
            ListTile automatically handles padding and alignment.
            You can use dense: true for a more compact look.
            Great for settings menus, contact lists, and navigation lists.

    00:40:59 print
        print() - prints to the console

    00:41:47 Wrap
        Automatically moves its children to the next line (or column) when there‚Äôs not enough space.
        It‚Äôs perfect for chips, tags, buttons, or any content that should flow responsively.
        Like a Row(), but wraps to next line
        Wrap(
            spacing: 8.0,       // space between items horizontally
            runSpacing: 4.0,    // space between lines vertically
            children: [
                Chip(label: Text('Flutter')),
                Chip(label: Text('Dart')),
                Chip(label: Text('UI')),
            ],
        );
        üß± Common properties:
            direction ‚Üí layout direction (Axis.horizontal by default)
            spacing ‚Üí space between children in the main axis
            runSpacing ‚Üí space between lines (runs) in the cross axis
            alignment ‚Üí alignment of children in the main axis
            runAlignment ‚Üí ali
        üìå Tip:
            Use Wrap instead of Row or Column when you want auto line breaking.
            Unlike Row and Column, Wrap won‚Äôt overflow when space runs out ‚Äî it wraps gracefully.
            Commonly used in responsive UIs.


üê¶‚Äçüî• 3. Master Layout
    00:43:17 MaterialApp & Scaffold

    *** MaterialApp is the root widget for apps that use Material Design.
        It provides essential features like theming, routing, navigation,
        and localization out of the box.

        MaterialApp(
            title: 'My App',
            theme: ThemeData(
                primarySwatch: Colors.blue,
            ),
            home: HomePage(),  // your first screen widget
        );

        üß± Common properties:
            title ‚Üí name of the app (shown in task switchers, etc.)
            theme ‚Üí defines colors, fonts, and overall visual style
            home ‚Üí the default screen shown when the app starts
            routes ‚Üí named routes for navigation
            initialRoute ‚Üí route shown at launch (instead of home)

                MaterialApp(
                    initialRoute: '/',
                    routes: {
                        '/': (context) => HomePage(),
                        '/about': (context) => AboutPage(),
                    },
                );

            debugShowCheckedModeBanner ‚Üí remove the ‚Äúdebug‚Äù banner in debug mode
        üìå Tip:
            Always wrap your Flutter app with MaterialApp if you want Material Design widgets (like Scaffold, AppBar, FloatingActionButton, etc.).
            For more control over appearance, use theme or darkTheme.
            For iOS-style apps, you can use CupertinoApp instead.
            üëâ Typically, MaterialApp is placed inside runApp() at the very top of your app.

    *** Scaffold is a basic layout structure for Material Design apps.
        It provides predefined slots for common app elements like AppBar, Drawer,
        BottomNavigationBar, FloatingActionButton, and body content.
        Scaffold(
            appBar: AppBar(
                title: Text('Home'),
            ),
            body: Center(
                child: Text('Hello, Flutter!'),
            ),
            floatingActionButton: FloatingActionButton(
                onPressed: () {},
                child: Icon(Icons.add),
            ),
        );
        üß± Common properties:
            appBar ‚Üí top bar of the screen (AppBar)
            body ‚Üí main content area (usually Column, Row, ListView, etc.)
            floatingActionButton ‚Üí circular action button
            drawer ‚Üí side navigation panel
            bottomNavigationBar ‚Üí bar at the bottom for navigation
            backgroundColor ‚Üí background color of the Scaffold
        üìå Tip:
            Scaffold is the foundation for most Material apps.
            It handles layout, safe area, scrolling, and keyboard overlap automatically.
            Combine with AppBar, Drawer, and FloatingActionButton for a complete UI structure.

    00:47:21 AppBar
        The top navigation bar in a Material Design app.
        It usually contains the title, actions, navigation buttons,
        and optional widgets like tabs.
        AppBar(
            title: Text('Home'),
            actions: [
                IconButton(
                    icon: Icon(Icons.search),
                    onPressed: () {},
                ),
            ],
        );
        üß± Common properties:
            title ‚Üí main text or widget displayed in the center (or start)
            leading ‚Üí widget at the start (commonly back button or drawer icon)
            actions ‚Üí list of widgets displayed at the end (icons, buttons)
            backgroundColor ‚Üí color of the AppBar
            centerTitle ‚Üí centers the title (default depends on platform)
            elevation ‚Üí shadow depth of the AppBar
        üìå Tip:
            AppBar is usually used inside a Scaffold.
            You can place custom widgets inside title or actions for flexible UI.
            For tabs, combine AppBar with TabBar inside a DefaultTabController.

    00:50:05 NavigationBar
        NavigationBar is the modern Material 3 widget for bottom navigation in Flutter.
        It lets users switch between top-level destinations of your app with a clean, minimal design.
        It‚Äôs the updated alternative to the older BottomNavigationBar.
        NavigationBar(
            selectedIndex: 0,
            onDestinationSelected: (int index) {
                print('Selected index: $index');
            },
            destinations: const [
                NavigationDestination(
                    icon: Icon(Icons.home),
                    label: 'Home',
                ),
                NavigationDestination(
                    icon: Icon(Icons.settings),
                    label: 'Settings',
                ),
            ],
        );
        üß± Common properties:
            selectedIndex ‚Üí currently active tab index
            onDestinationSelected ‚Üí callback when a tab is tapped
            destinations ‚Üí list of NavigationDestination widgets (tabs), must be 2+ items
            backgroundColor ‚Üí background of the bar
            indicatorColor ‚Üí highlight color for the selected destination
            animationDuration ‚Üí how fast the transition animates
        üìå Tip:
            NavigationBar works great with Scaffold as bottomNavigationBar.
            It‚Äôs part of Material 3, so make sure useMaterial3: true is set in your ThemeData.
            Use NavigationDestination to define each tab‚Äôs icon and label.
            For older Material 2 designs, use BottomNavigationBar instead.

    00:53:53 FloatingActionButton
        FloatingActionButton (FAB) is a circular button that floats above the UI, usually in the bottom-right
        corner. It‚Äôs used for primary actions on a screen ‚Äî like adding, creating, or composing something.
        FloatingActionButton(
            onPressed: () {
                print('FAB pressed');
            },
            child: Icon(Icons.add),
        );
        üß± Common properties:
            onPressed ‚Üí callback when the button is tapped (required)
            child ‚Üí usually an Icon or small Text widget
            backgroundColor ‚Üí background color of the FAB
            foregroundColor ‚Üí color of the icon/text inside the FAB
            tooltip ‚Üí text shown when the user long-presses
            shape ‚Üí custom shape for the button (e.g., rounded rectangle)
        ! If multiple buttons are needed, can be wrapped with Row/column:
        floatingActionButton: Row(
            mainAxisSize: MainAxisSize.min,
            FloatingActionButton(...),
            SizedBox(width: 10),
            FloatingActionButton(...),
        )
        üìå Tip:
            FAB is typically placed inside a Scaffold using floatingActionButton.
            Use FloatingActionButton.extended when you want text + icon.
            You can position it with floatingActionButtonLocation.
            It should represent the most important action on the screen.

    00:56:11 Drawer
        Drawer is a side navigation panel that slides in from the left (or right) of the screen.
        It‚Äôs commonly used for app-wide navigation ‚Äî like accessing profile, settings, or other sections.
        It‚Äôs typically paired with Scaffold and accessed via the hamburger menu in the AppBar.
        Drawer(
            child: ListView(
                padding: EdgeInsets.zero,
                children: [
                    DrawerHeader(
                        decoration: BoxDecoration(color: Colors.blue),
                        child: Text('Menu', style: TextStyle(color: Colors.white)),
                    ),
                    ListTile(
                        leading: Icon(Icons.home),
                        title: Text('Home'),
                        onTap: () {},
                    ),
                    ListTile(
                        leading: Icon(Icons.settings),
                        title: Text('Settings'),
                        onTap: () {},
                    ),
                ],
            ),
        );
        üß± Common properties:
            child ‚Üí the widget displayed inside the drawer (commonly a ListView)
            backgroundColor ‚Üí background color of the drawer
            You can use DrawerHeader or UserAccountsDrawerHeader for profile info.
        üìå Tip:
            Place Drawer in Scaffold‚Äôs drawer: property to enable the hamburger menu automatically.
            Use Navigator.pop(context) inside onTap to close the drawer after selecting an option.
            You can also use endDrawer to make the drawer slide in from the right side.

    00:57:53 SafeArea
        SafeArea is a widget that automatically adds padding to its child so that it doesn‚Äôt get covered
        by system UI elements like the status bar, notch, or navigation bar. It‚Äôs super useful for making
        your layout look good on all devices, especially phones with notches.
        SafeArea(
            child: Text('Hello, Safe Area!'),
        );
        üß± Common properties:
            child ‚Üí the widget to be displayed safely
            left, top, right, bottom ‚Üí booleans to enable/disable padding on specific sides
            minimum ‚Üí adds extra padding beyond the safe area
            maintainBottomViewPadding ‚Üí keeps bottom padding even when keyboard is open
        üìå Tip:
            Use SafeArea around your main screen content to handle different screen cutouts automatically.
            You don‚Äôt need it inside a Scaffold with AppBar, since the AppBar already respects the top safe area.
            It‚Äôs especially useful for full-screen UIs or custom layouts without an AppBar.


üîß 4. Debugging
    00:59:49 Type 1
    01:01:20 Type 2
    01:05:26 Null Safety


‚ö° 5. States
    01:07:19 Stateful
        setState() is a method used inside a StatefulWidget to update the UI when the state changes.
        When you call setState(), Flutter rebuilds the widget tree to reflect the new state.
        setState(() {
            // Update your state variables here
        });
        üß± Key points:
            Only works inside the State class of a StatefulWidget.
            It triggers a rebuild of the widget to reflect the updated data.
            Should be used only when the state actually changes (to avoid unnecessary rebuilds).
        üìå Tip:
            Keep the code inside setState minimal‚Äîonly update variables, not perform heavy logic.
            If your state is complex or shared across multiple widgets, consider using state management solutions like Provider, Bloc, or Riverpod.
            setState() does not rebuild the entire app, only the widget where it‚Äôs called.

    01:11:42 Recap
        Stateful Widget passed to runApp(const MyApp());
        returns Material App
        home: Scaffold(
            appBar: AppBar(),
            bottomNavigationBar: NavigationBar(
                onDestinationSelected: (value) {
                    setState(() {
                        // use value
                    });
                }
            ),
        ),


    01:17:18 Split your Widgets
        Refactor widgets into separate files

    01:20:30 Widget Tree
        Refactor the main Scaffold() into a separate widget_tree.dart file outside of main
        Main should be simple and only return the MaterialApp(home: WidgetTree())


    01:25:12 ValueNotifier
        ValueNotifier is a special class that holds a single value and notifies its listeners
        whenever that value changes. It‚Äôs a lightweight alternative to setState() for updating UI reactively.

        ValueNotifier: holds the data
        ValueListenableBuilder: listens to the data (don't need the setState())

        1. Simple counter using ValueNotifier:

        final counter = ValueNotifier<int>(0);

        ValueListenableBuilder<int>(
            valueListenable: counter,
            builder: (context, value, child) {
                return Text('Count: $value');
            },
        );
        FloatingActionButton(
            onPressed: () {
                counter.value++;
            },
            child: Icon(Icons.add),
        );

        2. Updating a string value:

        final nameNotifier = ValueNotifier<String>('Guest');

        ValueListenableBuilder<String>(
            valueListenable: nameNotifier,
            builder: (context, value, _) {
                return Text('Hello, $value');
            },
        );

        // Update value
        nameNotifier.value = 'John';

        üß± Key points:
            Works well with ValueListenableBuilder to rebuild widgets automatically.
            value property holds the current state.
            When you update value, all listeners are notified.
            Doesn‚Äôt require a StatefulWidget ‚Äî can be used inside StatelessWidget too.

        üìå Tip:
            ValueNotifier is great for small, localized state management.
            For complex state, use more robust solutions like Provider, Riverpod, or Bloc.
            Unlike setState, you can use it even in a StatelessWidget because the rebuild happens through the listener.


    01:31:41 Challenge
        Create an AppBar button to switch the theme between Light and Dark mode

    01:34:30 Solution
        notifiers.dart
            - Create a new bool notifier - isDarkModeNotifier
        widget_tree.dart
            - In the AppBar, create actions: [IconButton(),]
            - IconButton
                - onPressed: toggle value of isDarkModeNotifier.value between true and false
                - icon: Icon(Icons.light_mode)
                - To switch icon between dark and light mode: wrap Icon() in ValueListenableBuilder(context, isDarkMode, child)
                    - in the builder function return Icon(value ? light mode icon : dark mode icon)
        main.dart
            - To switch theme between light and dark, wrap MaterialApp in ValueListenableBuilder(context, isDarkMode, child)
            - switch theme: ThemeData(brightness: isDarkMode ? Brightness.dart : Brightness.light),


üñãÔ∏è 6. User Inputs
    01:38:32 TextField
        TextField is a widget that allows the user to enter and edit text input.
        It‚Äôs commonly used for forms, search bars, login screens, and other input fields.

        TextField(
            decoration: InputDecoration(
                labelText: 'Enter your name',
            ),
        );

        üß± Common properties:
            controller ‚Üí controls and retrieves the text entered (TextEditingController)
            decoration ‚Üí adds styling like labels, icons, borders (InputDecoration)
            keyboardType ‚Üí specifies the keyboard type (e.g., TextInputType.emailAddress)
            obscureText ‚Üí hides text for passwords
            onChanged ‚Üí callback triggered when text changes
            onSubmitted ‚Üí callback when user presses "done" or "enter"
            maxLines ‚Üí allows multiple lines of input
        üìå Tip:
            Always dispose of your TextEditingController in dispose() to prevent memory leaks.
            Use TextFormField for validation when working inside a form.
            Combine with InputDecoration for professional-looking input fields.

    TextEditingController()
        TextEditingController is a controller class used to manage and control the text inside a
        TextField or TextFormField. It lets you read, modify, and listen to changes in the text input.

        Listen for text changes:
            final myController = TextEditingController();
            myController.addListener(() {
                print(myController.text);
            });

        Basic usage with TextField:
            final nameController = TextEditingController();
            TextField(
                controller: nameController,
                decoration: InputDecoration(
                    labelText: 'Enter your name',
                ),
            );
            // Access the text value
            print(nameController.text);

        üß± Common uses:
            Retrieve the current text: myController.text
            Set new text: myController.text = 'Hello';
            Clear the field: myController.clear();
        üìå Tip:
            Always dispose of controllers when they‚Äôre no longer needed to free resources:
                @override
                void dispose() {
                    nameController.dispose();
                    super.dispose();
                }
            Use one controller per text field when you need to track or control input directly.
            Combine with TextField or TextFormField for reactive and interactive input fields.

    01:42:33 Checkbox
        Checkbox is a material design widget that lets the user select or deselect an option (true/false).
        It‚Äôs typically used for settings, preferences, or multi-select lists.
        see also CheckboxListTile(title: )

        Checkbox(
            value: isChecked,
            onChanged: (bool? newValue) {
                setState(() {
                    isChecked = newValue!;
                });
            },
        );
        üß± Common properties:
            value ‚Üí current state (true or false)
            onChanged ‚Üí callback triggered when user taps the checkbox
            activeColor ‚Üí color when the box is checked
            checkColor ‚Üí color of the check mark
            tristate ‚Üí allows null as a third state if set to true
        üìå Tip:
            Always manage the state (with setState, ValueNotifier, or a state management solution).
            Use CheckboxListTile() for a built-in label and better accessibility.
            Use Switch if you want a toggle-style interaction instead of a checkbox.

    01:45:09 Arrow function
        A short syntax for writing functions that contain only one expression.
        It uses the => operator instead of curly braces {} and return.

        returnType functionName(parameters) => expression;
        is the same as:
        returnType functionName(parameters) {
            return expression;
        }

    01:46:15 Switch
        Switch is a material design toggle button that represents a boolean (on/off) state.
        It‚Äôs commonly used in settings screens or anywhere the user needs to enable or disable a feature.
        See also: SwitchListTile(title: )

        Switch(
            value: isSwitched,
            onChanged: (bool value) {
                setState(() {
                    isSwitched = value;
                });
            },
        );
        üß± Common properties:
            value ‚Üí current state of the switch (true or false)
            onChanged ‚Üí function called when the user toggles the switch
            activeColor ‚Üí color of the thumb (the circle) when the switch is ON
            activeTrackColor ‚Üí color of the track when ON
            inactiveThumbColor ‚Üí color of the thumb when OFF
            inactiveTrackColor ‚Üí color of the track when OFF
        üìå Tip:
            Switch itself only shows the toggle; use SwitchListTile for an easy labeled version.
            You must handle the state (like setState or ValueNotifier).
            Use Switch for binary (yes/no) options ‚Äî not multiple choices.

    01:47:57 .adaptive
        The .adaptive constructor is available on some Flutter widgets to make them
        automatically adapt to the platform‚Äôs design ‚Äî Material (Android) or Cupertino (iOS).
        That means:
            On Android ‚Üí shows a Material-style widget.
            On iOS ‚Üí shows a Cupertino-style (iOS-style) widget.

        ‚úÖ Other widgets with .adaptive constructors:
            Switch.adaptive
            Checkbox.adaptive
            CircularProgressIndicator.adaptive
            Slider.adaptive
        üìå Tip:
            Use .adaptive when you want your app‚Äôs UI to feel native on both Android and iOS.
            Flutter automatically detects the current platform using Theme.of(context).platform.
            It‚Äôs a quick way to achieve cross-platform design consistency without manually coding for each platform.

    01:49:11 Slider
        Slider is a material design input widget that lets users select a value from a continuous range by
        sliding a thumb along a track. It‚Äôs perfect for choosing numbers like volume, brightness, or progress.

        Slider(
            value: currentValue,
            min: 0,
            max: 100,
            onChanged: (double newValue) {
                setState(() {
                    currentValue = newValue;
                });
            },
        );

        üß± Common properties:
            value ‚Üí current slider position (a double)
            min ‚Üí minimum possible value
            max ‚Üí maximum possible value
            onChanged ‚Üí called when user moves the slider
            divisions ‚Üí splits the slider into discrete steps
            label ‚Üí shows a label when the slider thumb is dragged
            activeColor ‚Üí color of the track before the thumb
            inactiveColor ‚Üí color of the track after the thumb
        üìå Tip:
            Slider only supports double values ‚Äî you can round it using .round() if needed.
            Use Slider.adaptive() to automatically get iOS (Cupertino) or Android (Material) style.
            For range selection (e.g., min and max values), use RangeSlider.


    01:51:12 SingleChildScrollView
        SingleChildScrollView is a scrollable widget that allows a single child (like a Column, Row, or Container)
        to be scrolled when its content is too large to fit on the screen.
        It‚Äôs perfect for forms, long text, or any layout that might overflow vertically or horizontally.

        SingleChildScrollView(
            child: Column(
                children: [
                    Text('Item 1'),
                    Text('Item 2'),
                    // more widgets...
                ],
            ),
        );

        üß± Common properties:
            child ‚Üí the widget to scroll (usually a Column or Row)
            scrollDirection ‚Üí direction of scrolling (Axis.vertical or Axis.horizontal)
            padding ‚Üí space around the scrollable content
            reverse ‚Üí reverses the scroll direction
            physics ‚Üí defines scroll behavior (e.g., BouncingScrollPhysics, NeverScrollableScrollPhysics)
        üìå Tip:
            SingleChildScrollView is great for small-to-medium lists ‚Äî for large, dynamic data use ListView instead.
            Always wrap the child in a layout like Column or Row ‚Äî not multiple siblings directly.
            When used inside a Column, wrap it with Expanded or give it a constrained height (like using SizedBox) to avoid overflow errors.

    01:52:51 GestureDetector
        GestureDetector is a widget that detects gestures (taps, swipes, long presses, etc.) on its child.
        It doesn‚Äôt have a visible UI itself ‚Äî it simply wraps another widget to make it interactive.

        GestureDetector(
            onTap: () {
                print('Widget tapped!');
            },
            child: Container(
                color: Colors.blue,
                width: 100,
                height: 100,
                child: Center(child: Text('Tap me')),
            ),
        );

        üß± Common gesture callbacks:
            onTap ‚Üí single tap
            onDoubleTap ‚Üí double tap
            onLongPress ‚Üí long press
            onPanUpdate ‚Üí drag or swipe
            onVerticalDragUpdate / onHorizontalDragUpdate ‚Üí directional drag
            onTapDown / onTapUp ‚Üí when touch starts and ends
        üìå Tip:
            GestureDetector is invisible; you must wrap a widget to make it interactive.
            Use it when you need custom gestures beyond standard buttons or switches.
            For simple taps, InkWell() or InkResponse() can also be used, providing ripple effects.

    01:54:01 InkWell

    
    01:55:34 Buttons
    01:59:07 DropdownButton

üó∫Ô∏è 7. Navigation
    02:02:34 Push
    02:02:34 Pop
    02:09:16 PushReplacement
    02:10:59 Send Data Through pages

üëæ 8. Clean UI
    02:13:18 ClipRRect
    02:17:40 Hero
    02:22:14 SnackBar
    02:25:29 Alert
    02:29:06 Divider
    02:30:40 Card
    02:33:36 Text

üì¶ 9. Packages
    02:36:57 Lotties
    02:43:17 FittedBox
    02:46:50 UI modification
    02:54:33 Overrides
    02:56:49 UI modification
    03:01:20 UI modification (again)
    03:06:49 Verify and fix your App
    03:14:33 UI modification
    03:18:30 Shared Preferences
    03:26:33 UI modification
    03:37:57 UI modification (again)
    03:43:43 UI modification (again & again)
    03:55:57 Flutter Launcher Icons
    04:01:44 CircleAvatar

üì± 10. Responsive UI
    04:07:48 FractionallySizedBox
    04:09:55 LayoutBuilder
    04:12:41 MediaQuery
    04:14:42 AspectRatio
    04:17:40 Expanded & Flexible

üåê 11. Networking
    04:26:42 Intro
    04:29:00 Get
    04:37:56 Explain
    04:41:24 Class
    04:47:07 FutureBuilder
    04:53:41 AI

üéØ 12. Next Steps
    04:58:50 Let's talk about State Management
    05:00:59 Internationalizing
    05:02:12 Firebase
    05:03:25 Publish
    05:04:30 Animations
    05:10:14 The end.
