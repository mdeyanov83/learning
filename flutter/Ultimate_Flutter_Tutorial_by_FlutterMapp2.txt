The Ultimate Flutter Tutorial for Beginners - 2025 Full Course, by Flutter Mapp
https://www.youtube.com/watch?v=3kaGC_DrUnw

Chapters
🚀 1. Key Concepts
    00:00:00​ Create a project
    00:02:22 Widget inside Widget
    00:04:56 Widget vs Argument
    00:07:12 Types
    00:09:30 Mouse over

📐 2. Basic Layouts
    00:12:12 Container
    00:16:48 Column
    00:22:10 Row
    00:25:22 Center
    00:27:17 Images
    00:32:06 Extensions (only for VS code)
    00:33:27 Stack
    00:35:48 Padding
    00:36:46 SizedBox
    00:37:33 Icon
    00:38:56 ListTile
    00:40:59 print
    00:41:47 Wrap

🐦‍🔥 3. Master Layout
    00:43:17 MaterialApp & Scaffold
    00:47:21 AppBar
    00:50:05 NavigationBar
    00:53:53 FloatingActionButton
    00:56:11 Drawer
    00:57:53 SafeArea

🔧 4. Debugging
    00:59:49 Type 1
    01:01:20 Type 2
    01:05:26 Null Safety

⚡ 5. States
    01:07:19 Stateful
    01:11:42 Recap
    01:17:18 Split your Widgets
    01:20:30 Widget Tree
    01:25:12 ValueNotifier
    01:31:41 Challenge
    01:34:30 Solution

🖋️ 6. User Inputs
    01:38:32 TextField
    01:42:33 Checkbox
    01:45:09 Arrow function
    01:46:15 Switch
    01:47:57 .adaptive
    01:49:11 Slider
    01:51:12 SingleChildScrollView
    01:52:51 GestureDetector
    01:54:01 InkWell
    01:55:34 Buttons
    01:59:07 DropdownButton

🗺️ 7. Navigation
    Navigator() is a Flutter widget and class that manages a stack of routes (screens). It lets you navigate
    between pages, push new screens, and pop back to previous ones — like a web browser’s history.
    * Stack-based navigation:
        - Each screen is a route.
        - You can push (go forward) or pop (go back).

    Navigator.push(
        context,
        MaterialPageRoute(builder: (context) => SecondPage()),
        );
    Navigator.pop(context);
    🧱 Common methods:
        push()	            Opens a new route (screen) and adds it to the stack
        pop()	            Closes the current route and goes back
        pushReplacement()	Replaces the current route with a new one
        pushNamed() / popNamed()	Navigate using route names (defined in MaterialApp)
        canPop()	        Checks if there’s a route to go back to
    ✅ Examples:
        1. Navigate to a new page:
            Navigator.push(
                context,
                MaterialPageRoute(builder: (context) => SecondScreen()),
            );
        2. Go back to the previous page:
            Navigator.pop(context);
        3. Navigate with named routes (recommended for larger apps):
            In MaterialApp:
            MaterialApp(
                initialRoute: '/',
                routes: {
                    '/': (context) => HomeScreen(),
                    '/second': (context) => SecondScreen(),
                },
            );
        Navigate:
            Navigator.pushNamed(context, '/second');
            Navigator.pop(context);
        4. Replace current screen:
            Navigator.pushReplacement(
                context,
                MaterialPageRoute(builder: (context) => LoginScreen()),
            );
    📌 Tip:
        Use Navigator.pushNamed() for cleaner navigation when you have multiple screens.
        For modern navigation, consider go_router or Navigator 2.0 (Router API) for complex apps.
        Navigator works perfectly with Scaffold for building multi-screen apps.

    02:02:34 Push
        Navigator.push() is used to navigate to a new screen (route) by pushing it onto the navigation stack.
        It shows the new screen on top of the current one, allowing the user to go back later with Navigator.pop().
        Navigator.push(
            context,
            MaterialPageRoute(builder: (context) => NextPage()),
        );
        🧱 Parameters:
            context → The current widget’s build context.
            route → The route (page/screen) to display, usually a MaterialPageRoute.
        ✅ Example 1 – Navigate to another screen:
            // First screen
            ElevatedButton(
                onPressed: () {
                    Navigator.push(
                    context,
                    MaterialPageRoute(builder: (context) => SecondScreen()),
                    );
                },
                child: Text('Go to Second Screen'),
            );
            // Second screen
            class SecondScreen extends StatelessWidget {
                @override
                Widget build(BuildContext context) {
                    return Scaffold(
                        appBar: AppBar(title: Text('Second Screen')),
                        body: Center(
                            child: ElevatedButton(
                                onPressed: () {
                                    Navigator.pop(context); // Go back
                                },
                                child: Text('Back to First Screen'),
                            ),
                        ),
                    );
                }
            }
        ✅ Example 2 – Passing data to next screen:
            Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) => DetailScreen(item: 'Flutter Rocks!'),
                ),
            );
            class DetailScreen extends StatelessWidget {
                final String item;
                DetailScreen({required this.item});
                @override
                Widget build(BuildContext context) {
                    return Scaffold(
                        appBar: AppBar(title: Text('Detail Screen')),
                        body: Center(child: Text(item)),
                    );
                }
            }
        ✅ Example 3 – Getting a result from the next screen:
            final result = await Navigator.push(
                context,
                MaterialPageRoute(builder: (context) => ChooseColorScreen()),
            );
            print('User selected: $result');
            Then, in ChooseColorScreen:
            Navigator.pop(context, 'Blue');
        📌 Tip:
            Use Navigator.pushNamed() if you’ve defined named routes in MaterialApp.
            Always use Navigator.pop(context) to return to the previous screen.
            Navigator.push() returns a Future that completes when the new route is popped — useful for receiving results back.

    02:02:34 Pop
        Navigator.pop() is used to close the current screen (or route) and go back to the previous one.
        It’s the reverse of Navigator.push().
        When called, it pops the top route off the navigation stack.

        Navigator.pop(context);

        🧱 Parameters:
            context → The current widget’s build context.
            result (optional) → Data you can return to the previous screen.
        ✅ Example 1 – Simple Back Navigation:
            ElevatedButton(
                onPressed: () {
                    Navigator.pop(context);
                },
                child: Text('Go Back'),
            );
            ➡️ Returns to the previous screen that was pushed using Navigator.push().

        ✅ Example 2 – Returning data to previous screen:
            Second screen:
                ElevatedButton(
                    onPressed: () {
                        Navigator.pop(context, 'Hello from Second Screen!');
                    },
                    child: Text('Return Data'),
                );
            First screen:
                final result = await Navigator.push(
                    context,
                    MaterialPageRoute(builder: (context) => SecondScreen()),
                );
                print(result); // Output: Hello from Second Screen!
        ✅ Example 3 – Conditional pop:
            if (Navigator.canPop(context)) {
                Navigator.pop(context);
            }
            ➡️ Checks if there’s a previous screen before popping (avoids errors if at the root).
        📌 Tip:
            Navigator.pop() works only if a route was pushed before.
            You can return data by passing it as the second argument.
            Use it to close dialogs, modals, or bottom sheets too (not just pages).
            Example:
                showDialog(
                    context: context,
                    builder: (context) => AlertDialog(
                        title: Text('Confirm'),
                        actions: [
                            TextButton(
                                onPressed: () => Navigator.pop(context, false),
                                child: Text('Cancel'),
                            ),
                            TextButton(
                                onPressed: () => Navigator.pop(context, true),
                                child: Text('OK'),
                            ),
                        ],
                    ),
                );
                ➡️ The dialog returns true or false when popped!

    02:09:16 PushReplacement
        *** Navigator.pushReplacement() is used to navigate to a new screen while replacing the current one.
        That means the previous screen is removed from the navigation stack — the user cannot go back using the back button.
        It’s often used for navigation flows like login → home screen or splash → main app.

        Navigator.pushReplacement(
            context,
            MaterialPageRoute(builder: (context) => NewScreen()),
        );
        🧱 Parameters:
            context → current widget’s BuildContext
            route → the route (screen) to replace with
            result (optional) → data returned to the replaced route
        ✅ Example 1 – Replace login with home screen:
            ElevatedButton(
                onPressed: () {
                    Navigator.pushReplacement(
                    context,
                    MaterialPageRoute(builder: (context) => HomeScreen()),
                    );
                },
                child: Text('Login'),
            );
            ➡️ The user goes to HomeScreen and can’t go back to LoginScreen.
        ✅ Example 2 – Replace with named route:
            Navigator.pushReplacementNamed(context, '/home');
        ✅ Example 3 – Replace and send back a result:
            Navigator.pushReplacement(
                context,
                MaterialPageRoute(builder: (context) => NextScreen()),
                result: 'Replaced!',
            );
        📌 Tip:
            Use pushReplacement() when you don’t want users to return to the previous screen.
            For example:
            After login → home screen
            After splash → main app
            After onboarding → main content
            If you need to remove all previous routes, use:
            Navigator.pushAndRemoveUntil(
                context,
                MaterialPageRoute(builder: (context) => HomeScreen()),
                (route) => false, // removes all previous routes
            );

        *** Navigator.pushAndRemoveUntil() is used to navigate to a new screen and remove previous routes from the
        navigation stack until a given condition is met. This is useful for things like login flows — where you
        want to go to a home screen and prevent the user from going back to the login page.

        Navigator.pushAndRemoveUntil(
            context,
            MaterialPageRoute(builder: (context) => NewScreen()),
            (Route<dynamic> route) => false,
        );

        🧱 Parameters:
            context → The build context.
            MaterialPageRoute → The route (new page) to push.
            predicate → A condition that decides which previous routes to keep.
            If you return false, all previous routes are removed.
            If you return true for a specific route, that route and the ones below it are kept.

        ✅ Example 1 – Remove all previous routes:
            Navigator.pushAndRemoveUntil(
                context,
                MaterialPageRoute(builder: (context) => HomeScreen()),
                (route) => false,
            );
        📌 This pushes HomeScreen and clears the entire stack. The user can’t go back.

        ✅ Example 2 – Keep the first route (like a splash or root):
            Navigator.pushAndRemoveUntil(
                context,
                MaterialPageRoute(builder: (context) => HomeScreen()),
                (route) => route.isFirst,
            );
        📌 This keeps only the first screen in the stack and removes everything else.

        ✅ Example 3 – Conditional removal:
            Navigator.pushAndRemoveUntil(
                context,
                MaterialPageRoute(builder: (context) => Dashboard()),
                (route) => route.settings.name == '/login',
            );
        📌 This keeps only the /login route and removes others.

        🧠 When to use:
            After successful login/signup (to prevent going back to auth screen).
            To reset the navigation stack after logout or onboarding.
            To redirect users to a main page and clear history.
        📌 Tip
            Similar to pushReplacement(), but more powerful because it can remove multiple previous routes.
            Make sure to set up RouteSettings names if you plan to use named predicates.

    02:10:59 Send Data Through pages
        To send data through to pages - use a required named parameter as an input


👾 8. Clean UI
    02:13:18 ClipRRect
        ClipRRect is a widget that clips its child using a rounded rectangle.
        It’s commonly used to give widgets like images, containers, or cards
        rounded corners. RRect stands for “rounded rectangle”.

        ClipRRect(
            borderRadius: BorderRadius.circular(12),
            child: Image.asset('assets/image.png'),
        );

        🧱 Common properties:
            borderRadius → controls the roundness of the corners
            clipBehavior → defines how clipping is applied (e.g., Clip.antiAlias, Clip.hardEdge)
            child → the widget to be clipped
        ✅ Examples:
            1. Rounded image:
                ClipRRect(
                    borderRadius: BorderRadius.circular(20),
                    child: Image.asset(
                        'assets/photo.jpg',
                        width: 200,
                        height: 200,
                        fit: BoxFit.cover,
                    ),
                );
            2. Rounded container:
                ClipRRect(
                    borderRadius: BorderRadius.circular(30),
                    child: Container(
                        color: Colors.blue,
                        width: 150,
                        height: 150,
                    ),
                );
            3. With custom radius per corner:
                ClipRRect(
                    borderRadius: BorderRadius.only(
                        topLeft: Radius.circular(20),
                        bottomRight: Radius.circular(40),
                    ),
                    child: Container(
                        color: Colors.green,
                        width: 150,
                        height: 150,
                    ),
                );
        📌 Tip:
            ClipRRect only clips the visible area — it doesn’t affect the layout.
            For rounded corners on Container backgrounds, you can also use BoxDecoration with borderRadius.
            Use ClipOval if you want to make a circle or ellipse shape instead.

    02:17:40 Hero()
        Hero() is a widget that provides a shared element transition between two routes (screens).
        When you navigate to another page, the Hero widget animates the transition of a matching
        widget smoothly between the screens.
        This is great for image previews, profile pictures, or cards that expand into detail pages.

        Hero(
            tag: 'hero-tag',
            child: Image.asset('assets/image.png'),
        );

        ⚡ Important:
            Both the source and destination Hero must have the same tag.
            The tag must be unique for each Hero pair.
        🧱 Common properties:
            tag → unique identifier to match Hero widgets between screens.
            child → the widget to animate.
            flightShuttleBuilder → optional, allows customizing the animation look.
            transitionOnUserGestures → allows transitions during back gesture (iOS).
        ✅ Example 1 – Simple Hero animation:
            First screen:
                GestureDetector(
                    onTap: () {
                        Navigator.push(
                        context,
                        MaterialPageRoute(builder: (context) => SecondScreen()),
                        );
                    },
                    child: Hero(
                        tag: 'profile',
                        child: Image.asset(
                        'assets/avatar.png',
                        width: 100,
                        ),
                    ),
                );
            Second screen:
                Hero(
                    tag: 'profile',
                    child: Image.asset(
                        'assets/avatar.png',
                        width: 300,
                    ),
                );
            🪄 When you tap the image, it smoothly grows from 100px to 300px as the new screen opens.
        ✅ Example 2 – Custom transition using flightShuttleBuilder:
            Hero(
                tag: 'logo',
                flightShuttleBuilder: (flightContext, animation, direction, fromContext, toContext) {
                    return RotationTransition(
                    turns: animation,
                    child: Image.asset('assets/logo.png'),
                    );
                },
                child: Image.asset('assets/logo.png'),
            );
        📌 Tip:
            Hero animations work best with images or simple widgets.
            Always use the same tag on both widgets.
            Works automatically with Navigator.push() and Navigator.pop().
            You can wrap any widget in a Hero—not just images!
        🧭 Common use cases:
            Profile avatar → profile page
            Thumbnail image → fullscreen view
            Card preview → detail screen

    02:22:14 SnackBar
        SnackBar is a lightweight message displayed at the bottom of the screen to provide
        brief feedback to the user. It can include a simple message, an action (like “UNDO”),
        and disappears automatically after a few seconds.

        ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
                content: Text('This is a SnackBar!'),
            ),
        );

        🧱 Common properties:
            content → the main widget, usually a Text.
            backgroundColor → sets the background color of the snackbar.
            action → adds an optional button (e.g., “Undo”).
            duration → how long it stays visible.
            behavior → e.g., SnackBarBehavior.floating to make it float above UI.
            shape → gives rounded corners or custom shapes.
        ✅ Example 1 – Basic SnackBar:
            ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                    content: Text('Item added to cart'),
                ),
            );
        ✅ Example 2 – With action button:
            ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                    content: Text('Message deleted'),
                    action: SnackBarAction(
                    label: 'UNDO',
                    onPressed: () {
                        // Undo action here
                    },
                    ),
                ),
            );
        ✅ Example 3 – Floating & styled SnackBar:
            ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                    content: Text('Saved successfully!'),
                    backgroundColor: Colors.green,
                    behavior: SnackBarBehavior.floating,
                    shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(10),
                    ),
                    duration: Duration(seconds: 3),
                ),
            );
        📌 Tip:
            Always use ScaffoldMessenger.of(context) instead of the old Scaffold.of(context) (deprecated).
            SnackBar disappears automatically, but you can also dismiss it programmatically.
            Great for quick feedback like “Saved”, “Copied”, “Deleted”, etc.

    02:25:29 Alert - showDialog(), AlertDialog(), AboutDialog(), showAboutDialog()

        *** showDialog() is a built-in function used to display a modal dialog on top of the current screen.
        It blocks interaction with the rest of the app until the dialog is dismissed.
        It’s commonly used with widgets like AlertDialog or SimpleDialog.

        showDialog(
            context: context,
            builder: (BuildContext context) {
                return AlertDialog(
                    title: Text('Dialog Title'),
                    content: Text('This is the content of the dialog.'),
                    actions: [
                        TextButton(
                            onPressed: () => Navigator.pop(context),
                            child: Text('Close'),
                        ),
                    ],
                );
            },
        );

        🧱 Common parameters:
            context → required. The build context of the current widget.
            builder → returns the widget to display (e.g., AlertDialog).
            barrierDismissible → whether tapping outside closes the dialog (true by default).
            barrierColor → color behind the dialog (e.g., semi-transparent black).
            useSafeArea → ensures it doesn’t overlap system UI.
            useRootNavigator → decides which navigator to use.
        ✅ Example 1 – Simple AlertDialog:
            showDialog(
                context: context,
                builder: (context) {
                    return AlertDialog(
                        title: Text('Hello'),
                        content: Text('This is a simple dialog.'),
                        actions: [
                            TextButton(
                            onPressed: () => Navigator.pop(context),
                            child: Text('OK'),
                            ),
                        ],
                    );
                },
            );
        ✅ Example 2 – Non-dismissible dialog:
            showDialog(
                context: context,
                barrierDismissible: false,
                builder: (context) {
                    return AlertDialog(
                        title: Text('Wait'),
                        content: Text('You must choose an option.'),
                        actions: [
                            TextButton(
                            onPressed: () => Navigator.pop(context),
                            child: Text('OK'),
                            ),
                        ],
                    );
                },
            );
        ✅ Example 3 – Custom widget inside dialog:
            showDialog(
                context: context,
                builder: (context) {
                    return Dialog(
                        shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(20),
                        ),
                        child: Padding(
                            padding: const EdgeInsets.all(16),
                            child: Column(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                    Text('Custom Dialog', style: TextStyle(fontSize: 18)),
                                    SizedBox(height: 10),
                                    Text('You can put any widget here!'),
                                    SizedBox(height: 20),
                                    ElevatedButton(
                                    onPressed: () => Navigator.pop(context),
                                    child: Text('Close'),
                                    ),
                                ],
                            ),
                        ),
                    );
                },
            );
        📌 Tips:
            Always use Navigator.pop(context) to close the dialog.
            Return values can be passed from the dialog to the previous screen using Navigator.pop(context, value).
            You can also use showModalBottomSheet() for bottom popups.
        🧭 Common use cases:
            Confirmation dialogs (e.g., Delete / Cancel)
            Error or success messages
            Custom forms or widgets inside a popup


        *** AlertDialog() is a material design dialog that alerts the user to a situation and provides optional
        actions (e.g., OK / Cancel). It usually contains a title, a content message, and action buttons.

            showDialog(
                context: context,
                builder: (context) {
                    return AlertDialog(
                        title: Text('Alert'),
                        content: Text('This is an alert message.'),
                        actions: [
                            TextButton(
                                onPressed: () => Navigator.pop(context),
                                child: Text('Cancel'),
                            ),
                            TextButton(
                                onPressed: () {
                                    // Do something
                                    Navigator.pop(context);
                                },
                                child: Text('OK'),
                            ),
                        ],
                    );
                },
            );
        ✅ Example – Custom AlertDialog:
            showDialog(
                context: context,
                builder: (context) {
                    return AlertDialog(
                        title: Text('Delete Item'),
                        content: Text('Are you sure you want to delete this?'),
                        backgroundColor: Colors.white,
                        shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(15),
                        ),
                        actions: [
                            TextButton(
                            onPressed: () => Navigator.pop(context),
                            child: Text('No'),
                            ),
                            ElevatedButton(
                            onPressed: () {
                                // delete action
                                Navigator.pop(context);
                            },
                            child: Text('Yes'),
                            ),
                        ],
                    );
                },
            );

        🧱 Common properties:
            title → top of the dialog (usually Text).
            content → main message or widget.
            actions → list of buttons (e.g., TextButton).
            shape → customize the border shape.
            backgroundColor → set background color.

        *** AboutDialog() is a prebuilt widget that displays information about your app, such as its name, version,
        icon, and legal details. It’s typically used in “About” sections of apps.

        showDialog(
            context: context,
            builder: (context) {
                return AboutDialog(
                    applicationName: 'My Flutter App',
                    applicationVersion: '1.0.0',
                    applicationIcon: Icon(Icons.info),
                    applicationLegalese: '© 2025 My Company',
                );
            },
        );
        🧱 Common properties:
            applicationName → Name of your app.
            applicationVersion → Version number of the app.
            applicationIcon → Icon widget shown at the top.
            applicationLegalese → Legal text or copyright.
            children → Extra widgets for additional info.
        ✅ Example – Custom AboutDialog:
            showDialog(
                context: context,
                builder: (context) {
                    return AboutDialog(
                        applicationName: 'CoolApp',
                        applicationVersion: '2.5.1',
                        applicationIcon: Icon(Icons.flutter_dash),
                        applicationLegalese: '© 2025 Cool Company',
                        children: [
                            Text('This app is built with Flutter.'),
                            Text('All rights reserved.'),
                        ],
                    );
                },
            );
        🧭 Common use cases:
            Adding an “About” section in your settings page.
            Displaying app version and legal info.
            Showing credits or acknowledgements.
        📌 Tip:
            AlertDialog is used for actions and confirmations.
            AboutDialog is used for static info about the app.
            Both appear on top of the UI and block interaction until dismissed.

        *** showAboutDialog() is a built-in function that quickly displays an “About” dialog with your app’s
        information (name, version, icon, legal text, etc.).
        It’s a shortcut for showing an AboutDialog widget without manually wrapping it in showDialog().

        showAboutDialog(
            context: context,
            applicationName: 'My Flutter App',
            applicationVersion: '1.0.0',
            applicationIcon: Icon(Icons.info),
            applicationLegalese: '© 2025 My Company',
            children: [
                Text('This app is built with Flutter.'),
            ],
        );

        🧱 Common parameters:
            context → required, the build context of the current widget.
            applicationName → name of your app.
            applicationVersion → version number.
            applicationIcon → widget displayed at the top (e.g., app icon).
            applicationLegalese → legal text or copyright notice.
            children → optional extra widgets to display below the legalese.
        ✅ Example – showAboutDialog with legal info:
            showAboutDialog(
                context: context,
                applicationName: 'MyApp',
                applicationVersion: '2.0.0',
                applicationIcon: Icon(Icons.flutter_dash),
                applicationLegalese: '© 2025 My Company',
                children: [
                    Text('This app is built with Flutter.'),
                    Text('All rights reserved.'),
                ],
            );
        📌 Difference between AboutDialog and showAboutDialog():
            🧱 AboutDialog → Widget (you can use it inside your own showDialog).
            ⚡ showAboutDialog() → Function (displays the dialog immediately with less boilerplate).
        🧭 Common use cases:
            “About” section in settings screens.
            Displaying app version and copyright.
            Giving credits or contact info.

    02:29:06 Divider + VerticalDivider
        Divider() is a simple horizontal line used to visually separate content in a layout — for example,
        between list items or sections. It’s lightweight and commonly used in Column or ListView widgets.

        Divider(
            color: Colors.teal,
            thickness: 5.0,
            endIndent: 200,
        ),
        🧱 Common properties:
            color → color of the line.
            thickness → how thick the line is.
            height → total vertical space the divider takes (includes padding).
            indent → empty space at the start of the line.
            endIndent → empty space at the end of the line.
        ✅ Example 1 – Basic divider:
            Column(
                children: [
                    Text('Section 1'),
                    Divider(),
                    Text('Section 2'),
                ],
            );
        ✅ Example 2 – Custom styled divider:
            Divider(
                color: Colors.grey,
                thickness: 2,
                height: 30,
                indent: 20,
                endIndent: 20,
            );
        This creates a gray, thick divider with spacing and indents.
        ✅ Example 3 – In a list:
            ListView(
                children: [
                    ListTile(title: Text('Item 1')),
                    Divider(),
                    ListTile(title: Text('Item 2')),
                    Divider(),
                    ListTile(title: Text('Item 3')),
                ],
            );
        📌 Tip:
            Use VerticalDivider() if you want a vertical line (e.g., in Row).
            Divider automatically takes the full available width unless indents are applied.
            It’s purely decorative — doesn’t affect layout structure beyond spacing.

    02:30:40 Card
        Card is a material design container with rounded corners, elevation (shadow), and padding. It’s commonly
        used to group related information like images, text, and buttons in a visually distinct box.
        Card(
            child: Padding(
                padding: EdgeInsets.all(16),
                child: Text('This is a simple card'),
            ),
        );
        🧱 Common properties:
            child → the content inside the card.
            color → background color.
            elevation → shadow depth; higher values create bigger shadows.
            shape → custom border shape (e.g., rounded corners).
            margin → space around the card.
            clipBehavior → how child content is clipped (useful for images).
        ✅ Example 1 – Basic card:
            Card(
                elevation: 5,
                child: Padding(
                    padding: EdgeInsets.all(16),
                    child: Text('Hello, this is a card!'),
                ),
            );
        ✅ Example 2 – Card with rounded corners and color:
            Card(
                color: Colors.blue[50],
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(15),
                ),
                elevation: 8,
                child: Padding(
                    padding: EdgeInsets.all(20),
                    child: Text('Custom styled card'),
                ),
            );
        ✅ Example 3 – Card with image and text:
            Card(
                elevation: 5,
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(10),
                ),
                child: Column(
                    children: [
                        ClipRRect(
                            borderRadius: BorderRadius.vertical(top: Radius.circular(10)),
                            child: Image.asset('assets/photo.jpg', height: 150, fit: BoxFit.cover),
                        ),
                        Padding(
                            padding: EdgeInsets.all(16),
                            child: Text('Card with image and text'),
                        ),
                    ],
                ),
            );
        📌 Tip:
            Cards automatically follow Material Design principles with shadows and rounded corners.
            Use ClipRRect or clipBehavior to ensure images inside the card respect the border radius.
            Cards are perfect for lists of items, product previews, or info panels.

    02:33:36 Text
        Text() is the most basic widget for displaying a string of text in Flutter.
        You can style it, align it, and control how it behaves inside layouts.
        Text('Hello, Flutter!');
        🧱 Common properties:
            style → customize font size, color, weight, etc. (TextStyle)
            textAlign → horizontal alignment (TextAlign.left, .center, .right)
            overflow → handling text overflow (TextOverflow.ellipsis, .fade)
            maxLines → maximum number of lines to display
            softWrap → whether text wraps at soft line breaks
        ✅ Example 1 – Basic text:
            Text('Welcome to Flutter!');
        ✅ Example 2 – Styled text:
            Text(
                'Flutter is awesome!',
                style: TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                    color: Colors.blue,
                    fontStyle: FontStyle.italic,
                ),
                textAlign: TextAlign.center,
            );
        ✅ Example 3 – Text overflow:
            Text(
                'This is a very long text that might not fit on one line',
                maxLines: 1,
                overflow: TextOverflow.ellipsis, // shows "..."
            );
        ✅ Example 4 – Rich text (multiple styles in one string):
            Text.rich(
                TextSpan(
                    text: 'Hello ',
                    children: [
                    TextSpan(
                        text: 'Flutter',
                        style: TextStyle(fontWeight: FontWeight.bold, color: Colors.blue),
                    ),
                    TextSpan(text: '!'),
                    ],
                ),
            );
        📌 Tip:
            Use Text for any static or dynamic text display.
            For clickable or styled parts of text, combine Text.rich with GestureRecognizer.
            Always consider wrapping Text in a Flexible or Expanded when inside Row or Column to prevent overflow.


📦 9. Packages
    02:36:57 Lottie
        Create, manage and implement lightweight animations across websites,
        apps, presentations, social and more. https://lottiefiles.com/
        * Install package:
            https://pub.dev/packages/lottie
            flutter pub add lottie
        * How to use:
            https://pub.dev/packages/lottie/example

            Use as a basic widget:
            Lottie.asset('path/to/asset/lottie.json'),

    02:43:17 FittedBox
        FittedBox() is a widget that scales and positions its child to fit within its parent.
        It’s useful when you want a child (like Text, Image, or Container) to adjust size
        automatically to avoid overflow or fill available space.
        FittedBox(
            child: Text('Hello, Flutter!'),
        );

        🧱 Common properties:
            child → the widget to scale.
            fit → how to fit the child (BoxFit.contain, .cover, .fill, .scaleDown).
            alignment → alignment of the child inside the parent (Alignment.center, .topLeft, etc.).
            clipBehavior → clipping behavior when child exceeds bounds
        ✅ Example 1 – Basic FittedBox with text:
            Container(
                width: 150,
                height: 50,
                color: Colors.blue[50],
                child: FittedBox(
                    child: Text(
                    'This text will scale to fit the box',
                    style: TextStyle(fontSize: 20),
                    ),
                ),
            );
            ➡️ The text automatically scales to fit inside the Container.
        ✅ Example 2 – Image scaled to fit:
            FittedBox(
                fit: BoxFit.cover,
                child: Image.asset('assets/photo.jpg'),
            );
            ➡️ The image fills the parent widget according to the BoxFit rule.
        ✅ Example 3 – Aligning child inside FittedBox:
            FittedBox(
                alignment: Alignment.centerRight,
                child: Text(
                    'Aligned text',
                    style: TextStyle(fontSize: 30),
                ),
            );
        📌 Tip:
            Use FittedBox to avoid overflow for long text or large images inside constrained spaces.
            For scaling only text, consider combining with BoxConstraints or Flexible.
            Be careful: scaling large widgets too much can affect performance or readability.


    02:46:50 UI modification (1)

    02:54:33 Overrides in a Stateful Widget

        *** InitState()
        initState() is a lifecycle method of the State class in Flutter.
        It is called exactly once when a StatefulWidget is inserted into
        the widget tree, before the widget is displayed.
        You typically use it to:
            Initialize variables
            Set up listeners or controllers
            Fetch initial data

        @override
        void initState() {
            super.initState();
            // Initialization code here
        }

        🧱 Key points:
            Always call super.initState() first inside the method.
            Runs before the build() method.
            Called only once during the lifecycle of the state object.
            Good place for setting up things like TextEditingController, AnimationController, or API calls.
        📌 Tip:
            Do not use BuildContext to access InheritedWidget (like Theme.of) directly inside initState() — use WidgetsBinding.instance.addPostFrameCallback if needed after build.
            Use initState() for one-time setup logic only — not for UI updates.
        🧭 Lifecycle Order (Simplified):
            initState() → setup once ✅
            build() → builds UI 🧱
            didUpdateWidget() → when widget changes 🔁
            dispose() → cleanup 🧼

        ✅ Example 1 – Initializing a variable:

            class MyWidgetState extends State<MyWidget> {
                String message = '';
                @override
                void initState() {
                    super.initState();
                    message = 'Hello from initState!';
                }
                @override
                Widget build(BuildContext context) {
                    return Text(message);
                }
            }

        ✅ Example 2 – Setting up a controller:

            class MyWidgetState extends State<MyWidget> {
                final TextEditingController _controller = TextEditingController();
                @override
                void initState() {
                    super.initState();
                    _controller.text = 'Initial text';
                }
                @override
                void dispose() {
                    _controller.dispose(); // Always dispose controllers!
                    super.dispose();
                }
                @override
                Widget build(BuildContext context) {
                    return TextField(controller: _controller);
                }
            }

        ✅ Example 3 – Fetching data before UI builds:

            @override
            void initState() {
                super.initState();
                fetchData();
            }
            void fetchData() async {
                // Simulate API call
                await Future.delayed(Duration(seconds: 2));
                print('Data loaded');
            }

        *** dispose()
        dispose() is a lifecycle method of the State class that is called when a StatefulWidget
        is permanently removed from the widget tree. It’s used to clean up resources such as
        controllers, listeners, animations, or streams to prevent memory leaks.

        @override
        void dispose() {
            // Clean up resources here
            super.dispose();
        }

        🧱 Key points:
            Called only once when the state object is removed.
            Always call super.dispose() at the end of the method.
            Ideal for disposing controllers like TextEditingController, AnimationController, FocusNode, or streams.
        📌 Tip:
            Always clean up what you initialize in initState().
            Forgetting to dispose can cause memory leaks and performance issues.
            dispose() is never called if the app is force-closed, but always when a widget is removed properly from the tree.
        🧭 Lifecycle Order Recap:
            initState() → Initialize resources.
            build() → Render UI.
            didUpdateWidget() → Respond to updates.
            dispose() → Clean up resources. ✅

        ✅ Example 1 – Disposing a controller:

            class MyWidgetState extends State<MyWidget> {
                final TextEditingController _controller = TextEditingController();
                @override
                void dispose() {
                    _controller.dispose(); // important to prevent memory leaks
                    super.dispose();
                }
                @override
                Widget build(BuildContext context) {
                    return TextField(controller: _controller);
                }
            }

        ✅ Example 2 – Disposing an animation:

            class MyAnimationWidget extends State<MyWidget> with SingleTickerProviderStateMixin {
                late AnimationController _animationController;
                @override
                void initState() {
                    super.initState();
                    _animationController = AnimationController(
                    vsync: this,
                    duration: Duration(seconds: 2),
                    )..repeat();
                }
                @override
                void dispose() {
                    _animationController.dispose(); // stop and clean up animation
                    super.dispose();
                }
                @override
                Widget build(BuildContext context) {
                    return FadeTransition(
                    opacity: _animationController,
                    child: Text('Animating...'),
                    );
                }
            }

        ✅ Example 3 – Canceling a StreamSubscription:

            late StreamSubscription<int> _subscription;
            @override
                void initState() {
                super.initState();
                _subscription = Stream.periodic(Duration(seconds: 1), (i) => i)
                    .listen((event) => print(event));
            }
            @override
                void dispose() {
                _subscription.cancel();
                super.dispose();
            }

        *** OTHER COMMON OVERRIDES

        🧱 1️⃣ build(BuildContext context) — (always overridden)

            @override
            Widget build(BuildContext context) {
                return Container();
            }

            Required for State classes.
            Called every time the widget needs to be rebuilt.
            Should be pure — no side effects (like network calls).

        🧭 2️⃣ didChangeDependencies()

            @override
            void didChangeDependencies() {
                super.didChangeDependencies();
                // Called after initState, and whenever an InheritedWidget the state depends on changes
            }
            🧠 Use case:
                Responding to changes in inherited widgets (like MediaQuery, Theme, Localizations).
                Good place for code that relies on context (which isn’t fully available in initState() yet).
            👉 Common example:
                @override
                void didChangeDependencies() {
                    super.didChangeDependencies();
                    final mediaQuery = MediaQuery.of(context);
                }

        🔁 3️⃣ didUpdateWidget(covariant MyWidget oldWidget)
            @override
            void didUpdateWidget(MyWidget oldWidget) {
                super.didUpdateWidget(oldWidget);
                if (oldWidget.someValue != widget.someValue) {
                    // React to updated widget configuration
                }
            }
            🧠 Use case:
                When parent rebuilds the widget with new parameters (but the same State object).
                Ideal for reacting to updated props without recreating the whole state.
            👉 For example:
                if (oldWidget.userId != widget.userId) {
                    _loadUser(widget.userId);
                }

        🧪 4️⃣ deactivate()
            @override
            void deactivate() {
                super.deactivate();
                // Called when the State is removed from the tree (but may be reinserted later)
            }
            🧠 Use case:
            Cleanup when the widget is temporarily removed (e.g., during a navigation or reparenting).
            Rarely used compared to dispose(), but useful in some complex layouts.

        🧹 5️⃣ reassemble() (debug only)
            @override
            void reassemble() {
            super.reassemble();
            // Called on hot reload in debug mode
            }
            🧠 Use case:
                Used during hot reload only.
                Handy for debugging, reloading assets, resetting timers, etc.
            👉 Example:
                @override
                void reassemble() {
                    super.reassemble();
                    print('Hot reload triggered');
                }

        🧠 6️⃣ (Less common but valid) setState()
            You don’t usually override it, but you can if you want to intercept state changes (e.g., logging or batching).
            @override
            void setState(VoidCallback fn) {
                super.setState(fn);
                print('State changed!');
            }
            ⚠️ Use carefully — this affects all setState calls in that widget.

        7️⃣ Full State lifecycle overview
            Order of execution:
                createState() (in the widget)
                initState() ✅
                didChangeDependencies() ✅
                build() ✅ (can be called many times)
                didUpdateWidget() (if parent updates props) ✅
                deactivate() (if removed from tree)
                dispose() ✅

            Also:
                reassemble() on hot reload
                setState() whenever state updates

        8️⃣ Quick Summary Table
            Method	                When it’s called	                                Common use cases
            ------                  ----------------                                    ----------------
            initState()	            Once when State is created	                        Init controllers, listeners, load data
            didChangeDependencies() After initState + when inherited widgets change     Access context-dependent data
            build()	                On every rebuild	                                UI building (no side effects)
            didUpdateWidget()	    When parent passes new widget with updated fields   Respond to prop changes
            deactivate()	        When removed from tree                              Advanced cleanup, reparenting
            dispose()	            When State is permanently removed	                Dispose controllers, cancel streams
            reassemble()	        On hot reload (debug only)	                        Debugging, reloading assets
            setState() (override)   On state change                                     Debugging, logging

        ✅ In practice, the most commonly overridden methods besides are
            build() (always)
            initState()
            dispose()
            didChangeDependencies() → for context-related setup
            didUpdateWidget() → for reacting to prop changes


    02:56:49 UI modification (2)
    03:01:20 UI modification (again) (2)
    03:06:49 Verify and fix your App
    03:14:33 UI modification (3)

    03:18:30 Shared Preferences Plugin (Persistent storage / local storage)
        Wraps platform-specific persistent storage for simple data (NSUserDefaults on iOS and macOS,
        SharedPreferences on Android, etc.) - https://pub.dev/packages/shared_preferences

        * Install package
            flutter pub add shared_preferences

            pubspec.yaml
            dependencies:
                shared_preferences: ^2.5.3

            import 'package:shared_preferences/shared_preferences.dart';
        * How to use example
            // Obtain shared preferences.
            final SharedPreferences prefs = await SharedPreferences.getInstance();
            // Save an boolean value to 'repeat' key.
            await prefs.setBool('repeat', true);
            // Try reading data from the 'repeat' key. If it doesn't exist, returns null.
            final bool? repeat = prefs.getBool('repeat');
            // Remove data for the 'counter' key.
            await prefs.remove('counter');


    03:26:33 UI modification
    03:37:57 UI modification (again)
    03:43:43 UI modification (again & again) (4)

    *** List.generate()
        List.generate() is a factory constructor in Dart that creates a new list and fills it with
        values generated by a function. This is super useful when you want to build lists of widgets
        or numbers dynamically without manually typing each element.

        List.generate(length, (index) => value);

        🧱 Parameters:
            length → Number of elements in the list.
            generator (function) → A function that returns the value for each index.

        ✅ Example – Generate a list of widgets (common in Flutter):
        Column(
            children: List.generate(
                5,
                (index) => Text('Item $index'),
            ),
        );

        For use inside a children: [] property:
            - Wrap in a Column(
                children = List.generate(),
                )
            - Spread operator:
                 ...List.generate(),
            - Insert elements at specific positions:
                final widgetList = List.generate(2, (index) => Widget)
                children: [
                    widgetList[0],
                    widgetList[1],
                ]
        📌 Tip:
            Great for building repetitive widgets in loops.
            Can be combined with UI widgets like ListView or GridView.
            You can make the list growable by passing growable: true as a third argument:
            List<int> numbers = List.generate(3, (i) => i, growable: true);
            numbers.add(3);
            print(numbers); // [0, 1, 2, 3]
        🧠 Use cases in Flutter:
            Generating menu items
            Building dynamic UI lists
            Creating placeholders or skeleton loaders
            Populating test data quickly

    03:55:57 Flutter Launcher Icons
        A command-line tool which simplifies the task of updating your Flutter app's launcher icon.
        https://pub.dev/packages/flutter_launcher_icons
        * Installation:
            flutter pub add flutter_launcher_icons
            or in pubspec.yaml:
                dependencies:
                    flutter_launcher_icons: ^0.14.4
        * Setup the config file
            dart run flutter_launcher_icons:generate
        * flutter_launcher_icons.yaml
            Delete or comment out not-needed platforms
            Set the correct path to icon image .png file in
            image_path: "assets/path_to_icon/icon.png"
        * Run the package
            flutter pub get
            dart run flutter_launcher_icons


    04:01:44 CircleAvatar
        CircleAvatar is a widget used to display circular images or icons,
        often used for profile pictures, user initials, or avatars in apps.
        It automatically clips its child into a circle shape.

        CircleAvatar(
            radius: 30,              // size of the avatar
            backgroundColor: Colors.blue,
            child: Text('A'),
        )

        🧱 Common properties:
            radius → Controls the size of the circle.
            backgroundColor → Sets the background color.
            backgroundImage → Sets an image inside the avatar.
            child → Widget inside the avatar (like Text or Icon).
            foregroundImage → Displays an image on top (can be used with placeholders).

        ✅ Example 2 – Avatar with network image:
            CircleAvatar(
                radius: 40,
                backgroundImage: AssetImage('assets/path_to_image/image.jpg'),
                // backgroundImage: NetworkImage('https://example.com/profile.jpg'),
            );
        ✅ Example 3 – Avatar with icon:
            CircleAvatar(
                radius: 25,
                backgroundColor: Colors.green,
                child: Icon(
                    Icons.person,
                    color: Colors.white,
                    size: 30,
                ),
            );
        ✅ Example 4 – Using foregroundImage with placeholder color:
            CircleAvatar(
                radius: 35,
                backgroundColor: Colors.grey[300],
                foregroundImage: NetworkImage('https://example.com/avatar.png'),
                child: Icon(Icons.person, color: Colors.grey), // shows if image fails
            );
        📌 Tip:
            Perfect for profile sections, chat apps, and contact lists.
            You can wrap it with GestureDetector or InkWell to make it clickable.
            If using network images, consider handling errors (e.g., fallback icons or colors).
        🧠 Common use cases:
            Profile picture display 👤
            Contact lists / chat heads 📨
            Showing user initials when no image is available 🅰️
            Rounded icons for cleaner UI 🎨


📱 10. Responsive UI
    04:07:48 FractionallySizedBox
    04:09:55 LayoutBuilder
    04:12:41 MediaQuery
    04:14:42 AspectRatio
    04:17:40 Expanded & Flexible

🌐 11. Networking
    04:26:42 Intro
    04:29:00 Get
    04:37:56 Explain
    04:41:24 Class
    04:47:07 FutureBuilder
    04:53:41 AI

🎯 12. Next Steps
    04:58:50 Let's talk about State Management
    05:00:59 Internationalizing
    05:02:12 Firebase
    05:03:25 Publish
    05:04:30 Animations
    05:10:14 The end.
