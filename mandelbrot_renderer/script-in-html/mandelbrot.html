<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mandelbrot WebGL2</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>

    <script>
        const canvas = document.getElementById("glCanvas");
        const gl = canvas.getContext("webgl2");

        if (!gl) {
            alert("WebGL2 not supported in your browser!");
            throw new Error("WebGL2 not supported");
        }

        // Vertex shader source code
        const vertexShaderSource = `#version 300 es
        precision highp float;
        in vec2 vertexPosition;
        out vec2 uv;
        void main() {
            uv = vertexPosition * 0.5 + 0.5;  // Convert from -1 to 1 space to 0 to 1
            gl_Position = vec4(vertexPosition, 0.0, 1.0);
        }`;

        // Fragment shader source code (Mandelbrot Set)
        const fragmentShaderSource = `#version 300 es
        precision highp float;
        out vec4 fragColor;
        in vec2 uv;
        uniform vec2 u_center;
        uniform float u_zoom;
        uniform int u_iterations;
        uniform vec2 u_resolution;

        vec3 hsvToRgb(float h, float s, float v) {
            vec3 c = vec3(h * 6.0, s, v);
            vec3 rgb = clamp(abs(mod(c.x + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
            return c.z * mix(vec3(1.0), rgb, c.y);
        }

        void main() {
            vec2 aspectRatio = vec2(u_resolution.x / u_resolution.y, 1.0);
            vec2 c = (uv - vec2(0.5)) * (4.0 / u_zoom) * aspectRatio + u_center;
            vec2 z = vec2(0.0);
            int i;
            for (i = 0; i < u_iterations; i++) {
                if (dot(z, z) > 4.0) break;
                z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
            }
            float norm = float(i) / float(u_iterations);
            vec3 color = hsvToRgb(0.66 - 0.66 * norm, 1.0, norm < 1.0 ? 1.0 : 0.0);
            fragColor = vec4(color, 1.0);
        }`;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error("Shader compilation error: ", gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error("Shader program linking error:", gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
        gl.useProgram(program);

        // Vertex data (fullscreen quad)
        const vertices = new Float32Array([
            -1, -1,  1, -1,  -1, 1,
            -1, 1,  1, -1,  1, 1
        ]);
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        // Setup attributes
        const positionLocation = gl.getAttribLocation(program, "vertexPosition");
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // Get uniform locations
        const centerLocation = gl.getUniformLocation(program, "u_center");
        const zoomLocation = gl.getUniformLocation(program, "u_zoom");
        const iterationsLocation = gl.getUniformLocation(program, "u_iterations");
        const resolutionLocation = gl.getUniformLocation(program, "u_resolution");

        let centerX = -0.5, centerY = 0;
        let zoom = 1.0;
        let maxIterations = 500;

        function render() {
            gl.uniform2f(centerLocation, centerX, centerY);
            gl.uniform1f(zoomLocation, zoom);
            gl.uniform1i(iterationsLocation, maxIterations);
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);

            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            render();
        }

        window.addEventListener("resize", resizeCanvas);
        resizeCanvas();

        canvas.addEventListener("wheel", (e) => {
            e.preventDefault();
            let zoomFactor = e.deltaY > 0 ? 0.8 : 1.2;
            zoom *= zoomFactor;
            render();
        });

        let isDragging = false, lastX, lastY;
        canvas.addEventListener("mousedown", (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener("mousemove", (e) => {
            if (isDragging) {
                let dx = (e.clientX - lastX) / canvas.width * (4.0 / zoom);
                let dy = (e.clientY - lastY) / canvas.height * (4.0 / zoom);
                centerX -= dx;
                centerY += dy;
                lastX = e.clientX;
                lastY = e.clientY;
                render();
                console.log(centerX, centerY);
            }
        });

        canvas.addEventListener("mouseup", () => isDragging = false);
        canvas.addEventListener("mouseleave", () => isDragging = false);
    </script>
</body>
</html>
