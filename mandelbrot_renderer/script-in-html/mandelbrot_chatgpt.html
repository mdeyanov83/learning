<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL2 Mandelbrot</title>
    <style> body { margin: 0; overflow: hidden; } </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>

    <script>
        // Get canvas and initialize WebGL2
        const canvas = document.getElementById("glCanvas");
        const gl = canvas.getContext("webgl2");

        if (!gl) {
            alert("WebGL2 not supported!");
        }

        // Resize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            render();
        }
        window.addEventListener("resize", resizeCanvas);

        // Vertex Shader
        const vertexShaderSource = `#version 300 es
        in vec2 a_position;
        out vec2 v_uv;
        void main() {
            v_uv = (a_position + 1.0) * 0.5;
            gl_Position = vec4(a_position, 0.0, 1.0);
        }`;

        // Fragment Shader
        const fragmentShaderSource = `#version 300 es
        precision highp float;
        out vec4 fragColor;
        in vec2 v_uv;

        uniform vec2 u_center;
        uniform float u_zoom;
        uniform int u_iterations;
        uniform vec2 u_resolution;

        // Function to convert HSV to RGB
        vec3 hsv2rgb(float h, float s, float v) {
            float c = v * s;
            float x = c * (1.0 - abs(mod(h * 6.0, 2.0) - 1.0));
            float m = v - c;
            vec3 rgb = (h < 1.0/6.0) ? vec3(c, x, 0.0) :
                       (h < 2.0/6.0) ? vec3(x, c, 0.0) :
                       (h < 3.0/6.0) ? vec3(0.0, c, x) :
                       (h < 4.0/6.0) ? vec3(0.0, x, c) :
                       (h < 5.0/6.0) ? vec3(x, 0.0, c) :
                                       vec3(c, 0.0, x);
            return rgb + m;
        }

        void main() {
            vec2 aspectRatio = vec2(u_resolution.x / u_resolution.y, 1.0);
            vec2 c = (v_uv - vec2(0.5)) * (4.0 / u_zoom) * aspectRatio + u_center;
            vec2 z = vec2(0.0);
            int i;
            for (i = 0; i < u_iterations; i++) {
                if (dot(z, z) > 4.0) break;
                z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
            }

            float norm = float(i) / float(u_iterations); // Normalize iterations
            vec3 color = hsv2rgb(norm * 0.85, 1.0, norm < 1.0 ? 1.0 : 0.0); // Convert to color
            fragColor = vec4(vec3(color), 1.0);
        }`;

        // Create Shader Function
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error("Shader compile error: ", gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create WebGL Program
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error("Program link error: ", gl.getProgramInfoLog(program));
        }
        gl.useProgram(program);

        // Quad (Full-Screen Triangle Strip)
        const quadVertices = new Float32Array([
            -1, -1,   1, -1,   -1, 1,   1, 1
        ]);
        const vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, quadVertices, gl.STATIC_DRAW);
        const posLoc = gl.getAttribLocation(program, "a_position");
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        // Get Uniform Locations
        const resolutionLoc = gl.getUniformLocation(program, "u_resolution");
        const centerLoc = gl.getUniformLocation(program, "u_center");
        const zoomLoc = gl.getUniformLocation(program, "u_zoom");
        const iterationsLoc = gl.getUniformLocation(program, "u_iterations");

        // Initial Mandelbrot Variables
        let centerX = -0.7, centerY = 0.0;
        let zoom = 1.0;
        let maxIterations = 1500;

        // Render Function
        function render() {
            gl.useProgram(program); // Ensure we are using the program
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo); // Bind the buffer before drawing

            gl.uniform2f(resolutionLoc, canvas.width, canvas.height); // Now set u_resolution
            gl.uniform2f(centerLoc, centerX, centerY);
            gl.uniform1f(zoomLoc, zoom);
            gl.uniform1i(iterationsLoc, maxIterations);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        // Mouse Events for Zoom/Pan
        canvas.addEventListener("wheel", (e) => {
            zoom *= e.deltaY > 0 ? 0.9 : 1.1;
            render();
        });

        let isDragging = false, lastX, lastY;
        canvas.addEventListener("mousedown", (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener("mousemove", (e) => {
            if (isDragging) {
                let dx = (e.clientX - lastX) / canvas.width * (4.0 / zoom);
                let dy = (e.clientY - lastY) / canvas.height * (4.0 / zoom);
                centerX -= dx;
                centerY += dy;
                lastX = e.clientX;
                lastY = e.clientY;
                render();
            }
        });

        canvas.addEventListener("mouseup", () => { isDragging = false; });

        // Initial Draw
        resizeCanvas();
        render();
    </script>
</body>
</html>
